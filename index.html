<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>MH Now å¤é¾è¨˜éŒ„åœ°åœ–</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css">
  <style>
    body, html { margin: 0; padding: 0; }
    #map { height: 100vh; }
    .leaflet-control-custom {
      background: white;
      padding: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      font-size: 20px;
      width: 300px;
      box-sizing: border-box;
      border-radius: 8px;
    }
    .leaflet-control-custom .btn-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .leaflet-control-custom button {
      flex: 1;
      font-size: 22px;
      padding: 14px;
      min-height: 56px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #f9f9f9;
      cursor: pointer;
      transition: background 0.2s;
    }
    .leaflet-control-custom button:hover {
      background: #e0e0e0;
    }
    select[multiple] {
      width: 100%;
      font-size: 22px;
      padding: 10px;
      margin-bottom: 14px;
      border-radius: 6px;
    }
    @media (max-width: 600px) {
      .leaflet-control-custom {
        width: 100%;
        padding: 18px;
        font-size: 24px;
      }
      .leaflet-control-custom button {
        font-size: 28px;
        padding: 18px;
        min-height: 64px;
      }
      select[multiple], select, input[type="number"] {
        font-size: 28px;
        padding: 12px;
      }
    }
    .marker-wrapper {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .marker-border {
      border-radius: 50%;
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center;
    }
    .markerBorder {
      box-shadow: 0 0 0 6px red;
      border-radius: 50%;
      box-sizing: border-box;
    }
    #version, #zoomDisplay {
      position: absolute;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      font-size: 16px;
      border-radius: 4px;
      z-index: 1000;
    }
    #version { bottom: 10px; }
    #zoomDisplay { bottom: 40px; }
    .info-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 260px;
      background: white;
      padding: 14px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      font-size: 16px;
      font-family: Arial, sans-serif;
      z-index: 1000;
      display: block;
    }
    .info-panel h3 {
      margin: 0 0 10px;
      font-size: 18px;
      border-bottom: 1px solid #ccc;
    }
    .info-panel p {
      margin: 10px 0;
    }
    .leaflet-popup-content {
      display: none;
    }
    #markerEditModal {
      display: none;
      position: fixed;
      top: 20px;
      left: 20px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 30px;
      z-index: 10000;
      box-shadow: 0 10px 20px rgba(0,0,0,0.4);
      border-radius: 10px;
      width: 280px;
      font-size: 20px;
      line-height: 1.5;
    }
    #markerEditModal h3 {
      font-size: 26px;
      margin-top:0;
    }
    #markerEditModal select, #markerEditModal input {
      width: 100%;
      font-size: 22px;
      padding: 14px;
      margin-bottom: 14px;
      border-radius: 6px;
    }
    #markerEditModal button {
      font-size: 22px;
      padding: 14px;
      min-height: 56px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #f9f9f9;
      cursor: pointer;
      transition: background 0.2s;
    }
    #markerEditModal button:hover {
      background: #e0e0e0; }
    @media (max-width: 600px) {
      #markerEditModal {
        width: 90%;
        padding: 20px;
        font-size: 24px;
      }
      #markerEditModal h3 {
        font-size: 30px;
      }
      #markerEditModal select, #markerEditModal input {
        font-size: 28px;
        padding: 16px;
      }
      #markerEditModal button {
        font-size: 28px;
        padding: 18px 36px;
        min-height: 64px;
      }
    }
  </style>
</head>
<body>
  <div id="markerEditModal">
    <h3>æ›´æ”¹æ¨™è¨˜</h3>
    <label for="markerTime">æ™‚é–“ï¼š</label>
    <select id="markerTime">
    </select><br><br>
    <label for="timePeriod">æ™‚é–“æ®µ:</label>
    <input type="text" id="timePeriod" readonly><br><br>
    <label for="markerRemark">ç‹€æ…‹:</label>
    <select id="markerRemark">
    </select><br><br>
    <div style="text-align:right;">
      <button id="saveMarkerBtn" style="display:none;">å„²å­˜</button>
      <button onclick="document.getElementById('markerEditModal').style.display='none';const infoPanel=document.getElementById('infoPanel');if(infoPanel)infoPanel.style.display='block';">å–æ¶ˆ</button>
    </div>
  </div>
  <div id="map"></div>
  <div id="infoPanel" class="info-panel">
    <h3>æ¨™è¨˜è³‡è¨Š</h3>
    <div id="panelContent">è«‹é»é¸åœ°åœ–ä¸Šçš„æ¨™è¨˜æ¨™è¨˜</div>
  </div>
  <div id="version">ç‰ˆæœ¬ 4.2.23</div>
  <div id="zoomDisplay">Zoom: -</div>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script>
// æ‰€æœ‰æ™‚é–“è¡¨
const timeTableByTotalPoints = {
  1: ["06:15 07:05 07:55 08:45 09:35 10:25 11:15 12:05 12:55 13:45 14:35 15:25 16:15 17:05 17:55 18:45 19:35 20:25 21:15 22:05"],
  2: [
    "06:15 07:55 09:35 11:15 12:55 14:35 16:15 17:55 19:35 21:15 22:55",
    "07:05 08:45 10:25 12:05 13:45 15:25 17:05 18:45 20:25 22:05"
  ],
  3: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:55 10:25 12:55 15:25 17:55 20:25"
  ],
  4: [
    "06:15 07:55 09:35 11:15 12:55 14:35 16:15 17:55 19:35 21:15 22:55",
    "06:40 08:20 10:00 11:40 13:20 15:00 16:40 18:20 20:00 21:40 23:20",
    "07:05 08:45 10:25 12:05 13:45 15:25 17:05 18:45 20:25 22:05",
    "07:30 09:10 10:50 12:30 14:10 15:50 17:30 19:10 20:50 22:30"
  ],
  5: [
    "06:15 08:20 10:25 12:30 14:35 16:40 18:45 20:50 22:55",
    "06:40 08:45 10:50 12:55 15:00 17:05 19:10 21:15 23:20",
    "07:05 09:10 11:15 13:20 15:25 17:30 19:35 21:40",
    "07:30 09:35 11:40 13:45 15:50 17:55 20:00 22:05",
    "07:55 10:00 12:05 14:10 16:15 18:20 20:25 22:30"
  ],
  6: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "06:40 09:10 11:40 14:10 16:40 19:10 21:40",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:30 10:00 12:30 15:00 17:30 20:00 22:30",
    "07:55 10:25 12:55 15:25 17:55 20:25 22:55",
    "08:20 10:50 13:20 15:50 18:20 20:50 23:20"
  ],
  7: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "06:40 09:10 11:40 14:10 16:40 19:10 21:40",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:30 10:00 12:30 15:00 17:30 20:00 22:30",
    "07:55 10:25 12:55 15:25 17:55 20:25 22:55",
    "08:20 10:50 13:20 15:50 18:20 20:50 23:20"
  ],
  8: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "06:40 09:10 11:40 14:10 16:40 19:10 21:40",
    "07:05 09:35 12:05 14:35 17:05 18:45 20:25 22:05",
    "07:30 09:10 10:50 12:30 14:10 15:50 17:30 19:10 20:50 22:30",
    "07:55 10:25 12:55 15:25 17:55 20:25 22:55",
    "08:20 10:50 13:20 15:50 18:20 20:50 23:20"
  ]
};

// --- è¼”åŠ©å‡½æ•¸ ---
/**
 * æ ¹æ“šæ¨™è¨˜çš„æ™‚é–“æ’ç¨‹å’Œç•¶å‰å¯¦æ™‚æ™‚é–“ï¼Œåˆ¤æ–·ç•¶å‰æ´»èºæ™‚æ®µçš„å¥‡å¶ç‹€æ…‹ (1 æˆ– 2)ã€‚
 * @param {object} markerData åŒ…å« 'time' å±¬æ€§çš„æ¨™è¨˜è³‡æ–™ã€‚
 * @returns {string} å¦‚æœæ‰¾åˆ°æ´»èºæ™‚æ®µï¼Œè¿”å› '1' æˆ– '2'ï¼›å¦å‰‡è¿”å› 'ç„¡æ´»èºæ™‚æ®µ' æˆ– 'N/A'ã€‚
 */
function getCurrentActiveSlotOddEvenStatus(markerData) {
  const times = (markerData.time || "").split(/\s+/).filter(Boolean);
  if (!times.length) return "N/A"; // æ²’æœ‰è¨­å®šæ™‚é–“æ’ç¨‹

  const now = new Date();
  const nowMin = now.getHours() * 60 + now.getMinutes();
  const bufferMinutes = 9; // èˆ‡ getCustomIcon ä¸­ä½¿ç”¨çš„ç·©è¡æ™‚é–“ç›¸åŒ

  let currentSlotIndex = -1; // 0-indexed ä½ç½®

  for (let i = 0; i < times.length; i++) {
    const [h, m] = times[i].split(':').map(Number);
    const timeMin = h * 60 + m;

    let displayWindowStartMin = timeMin - bufferMinutes;
    // è™•ç†è·¨åˆå¤œçš„æ™‚é–“èµ·å§‹é»
    if (displayWindowStartMin < 0) displayWindowStartMin += 24 * 60;

    const nextTime = times[i + 1] || times[0]; // å¾ªç’°åˆ°æ’ç¨‹çš„ç¬¬ä¸€å€‹æ™‚é–“
    const [nh, nm] = nextTime.split(':').map(Number);
    let nextTimeMin = nh * 60 + nm;
    // å¦‚æœä¸‹ä¸€å€‹æ™‚é–“æ¯”ç•¶å‰æ™‚é–“å°ï¼ˆä»£è¡¨è·¨åˆå¤œäº†ï¼‰ï¼Œå‰‡åŠ ä¸Š24å°æ™‚çš„åˆ†é˜æ•¸
    if (nextTimeMin < timeMin) nextTimeMin += 24 * 60;

    // æª¢æŸ¥ç•¶å‰æ™‚é–“æ˜¯å¦è½åœ¨é€™å€‹æ™‚æ®µçš„æ´»èºçª—å£å…§
    let isNowWithinWindow = false;
    if (displayWindowStartMin <= nextTimeMin) {
      isNowWithinWindow = (nowMin >= displayWindowStartMin && nowMin < nextTimeMin);
    } else { // çª—å£è·¨åˆå¤œ (ä¾‹å¦‚ 23:00 åˆ° 01:00)
      isNowWithinWindow = (nowMin >= displayWindowStartMin || nowMin < nextTimeMin);
    }

    if (isNowWithinWindow) {
      currentSlotIndex = i;
      break;
    }
  }

  if (currentSlotIndex === -1) {
    return "ç„¡æ´»èºæ™‚æ®µ"; // æœªæ‰¾åˆ°ç•¶å‰æ´»èºæ™‚æ®µ
  }
  // è¿”å› 1 è¡¨ç¤ºå¥‡æ•¸ä½ç½® (ç´¢å¼• 0, 2, 4...)ï¼Œ2 è¡¨ç¤ºå¶æ•¸ä½ç½® (ç´¢å¼• 1, 3, 5...)
  return ((currentSlotIndex % 2) + 1).toString();
}

/**
 * å¾ä¸€å€‹å®Œæ•´çš„æ™‚é–“æ’ç¨‹å­—ä¸²ä¸­ï¼Œæ‰¾åˆ°èˆ‡ç•¶å‰æ™‚é–“æœ€æ¥è¿‘çš„é‚£å€‹å–®ä¸€æ™‚é–“é»ã€‚
 * è€ƒæ…®å·²éå»æ™‚é–“æ¯”å³å°‡åˆ°ä¾†æ™‚é–“æœ‰ 30 åˆ†é˜å„ªå‹¢çš„é‚è¼¯ã€‚
 * @param {string} scheduleString å®Œæ•´çš„æ™‚é–“æ’ç¨‹å­—ä¸² (e.g., "06:15 07:05 07:55")ã€‚
 * @returns {string} æœ€æ¥è¿‘çš„æ™‚é–“é»å­—ä¸² (e.g., "07:55")ã€‚å¦‚æœç„¡æœ‰æ•ˆæ™‚é–“å‰‡è¿”å›ç©ºå­—ä¸²ã€‚
 */
function getNearestTimePointInSchedule(scheduleString) {
  const times = scheduleString.split(/\s+/).filter(Boolean);
  if (!times.length) return "";

  const now = new Date();
  const nowMinutes = now.getHours() * 60 + now.getMinutes();

  let minClosenessScore = Infinity;
  let nearestTimePoint = "";

  for (const t of times) {
    const m = t.match(/(\d{1,2}):(\d{2})/);
    if (!m) continue;

    const h = parseInt(m[1], 10);
    const mm = parseInt(m[2], 10);
    const schedulePointMinutes = h * 60 + mm;

    let diff = schedulePointMinutes - nowMinutes;

    // èª¿æ•´ diff ä»¥è€ƒæ…®æ™‚é–“çš„å¾ªç’°æ€§ (ä¾‹å¦‚ 23:50 å’Œ 00:10)
    // é€™ç¢ºä¿ diff ä»£è¡¨æœ€çŸ­çš„æ™‚é–“å·® (åˆ†é˜)ï¼Œæ­£æ•¸è¡¨ç¤ºæœªä¾†ï¼Œè² æ•¸è¡¨ç¤ºéå»ã€‚
    if (diff > 12 * 60) { // å¦‚æœæœªä¾†æ™‚é–“è¶…é 12 å°æ™‚ (ä¾‹å¦‚ 00:10 ç›¸å°æ–¼å‰ä¸€å¤©çš„ 11:50)
      diff -= 24 * 60;
    } else if (diff < -12 * 60) { // å¦‚æœéå»æ™‚é–“è¶…é 12 å°æ™‚ (ä¾‹å¦‚ 11:50 ç›¸å°æ–¼ä¸‹ä¸€å¤©çš„ 00:10)
      diff += 24 * 60;
    }

    let closenessScore;
    if (diff >= 0) { // æœªä¾†æ™‚é–“ (æˆ–å‰›å¥½æ˜¯ç¾åœ¨)
      closenessScore = diff;
    } else { // éå»æ™‚é–“
      closenessScore = Math.abs(diff) - 30; // éå»æ™‚é–“ç²å¾— 30 åˆ†é˜çš„å„ªå‹¢
    }

    // å¦‚æœåˆ†æ•¸ç›¸åŒï¼Œå‰‡ä¿ç•™æ’ç¨‹å­—ä¸²ä¸­å…ˆå‡ºç¾çš„é‚£å€‹æ™‚é–“é» (ä½œç‚ºéš±å¼çš„å¹³å±€è™•ç†)
    if (closenessScore < minClosenessScore) {
      minClosenessScore = closenessScore;
      nearestTimePoint = t;
    }
  }
  return nearestTimePoint;
}


// === æ›´æ–°æ™‚é–“é¸é … (ç¾åœ¨æ¯å€‹é¸é …é¡¯ç¤ºæœ€æ¥è¿‘çš„æ™‚é–“é») ===
function updateTimeOptionsForEdit(totalPoints, initialSelectedTime) {
  const markerTimeSelect = document.getElementById('markerTime');
  const timePeriodInput = document.getElementById('timePeriod');

  markerTimeSelect.innerHTML = ''; // æ¸…é™¤ç¾æœ‰é¸é …

  // æ·»åŠ ä¸€å€‹é è¨­çš„ã€Œè«‹é¸æ“‡ã€é¸é …
  const defaultOpt = document.createElement('option');
  defaultOpt.value = ''; // ç©ºå€¼
  defaultOpt.textContent = 'è«‹é¸æ“‡æ™‚é–“æ’ç¨‹'; // æ›´æ˜ç¢ºçš„æç¤º
  markerTimeSelect.appendChild(defaultOpt);

  const arr = timeTableByTotalPoints[totalPoints] || [];
  arr.forEach(fullScheduleString => {
    const opt = document.createElement('option');
    opt.value = fullScheduleString; // value ä»ç„¶æ˜¯å®Œæ•´çš„æ’ç¨‹å­—ä¸²
    opt.textContent = getNearestTimePointInSchedule(fullScheduleString); // é¡¯ç¤ºæœ€æ¥è¿‘çš„å–®ä¸€æ™‚é–“é»
    markerTimeSelect.appendChild(opt);
  });

  // è¨­å®šé¸ä¸­å€¼
  if (initialSelectedTime) {
    markerTimeSelect.value = initialSelectedTime;
  } else {
    markerTimeSelect.value = ''; // å¦‚æœæ¨™è¨˜æ²’æœ‰æ™‚é–“ï¼Œå‰‡æ˜ç¢ºè¨­å®šç‚ºç©º
  }

  // === åœ¨é€™è£¡æ·»åŠ  onchange äº‹ä»¶ç›£è½å™¨ï¼Œç•¶é¸æ“‡æ™‚é–“æ’ç¨‹æ™‚ç«‹å³æ›´æ–°æ™‚é–“æ®µ ===
  markerTimeSelect.onchange = () => {
    const selectedTimeSchedule = markerTimeSelect.value;
    const tempMarkerData = { time: selectedTimeSchedule };
    timePeriodInput.value = getCurrentActiveSlotOddEvenStatus(tempMarkerData);
  };

  // === åˆå§‹åŠ è¼‰æ™‚ï¼Œä¹Ÿæ ¹æ“šé¸ä¸­çš„æ™‚é–“ï¼ˆæˆ–ç„¡é¸ä¸­ï¼‰æ›´æ–°æ™‚é–“æ®µ ===
  const initialTempMarkerData = { time: markerTimeSelect.value };
  timePeriodInput.value = getCurrentActiveSlotOddEvenStatus(initialTempMarkerData);
}


// === æ›´æ–° remark é¸é … (æ–°å¢è‡ªå‹•ä¿å­˜å’Œé—œé–‰ç·¨è¼¯æ¬„çš„é‚è¼¯) ===
function updateRemarkOptionsForEdit(remark) {
  const markerRemark = document.getElementById('markerRemark');
  const defaultOptions = [
    'A ? A ? ç¢ºèª',
    '? A ? A ç¢ºèª',
    'B ? B ? ç¢ºèª',
    '? B ? B ç¢ºèª',
    'A A A Aç¢ºèª',
    'A B A Bç¢ºèª',
    'B B B Bç¢ºèª',
    'B A B Aç¢ºèª'
  ];
  markerRemark.innerHTML = '';

  defaultOptions.forEach(optValue => {
    const opt = document.createElement('option');
    opt.value = optValue;
    opt.textContent = optValue;
    markerRemark.appendChild(opt);
  });

  if (remark === 'f') {
    const opt = document.createElement('option');
    opt.value = 'f';
    opt.textContent = 'ç„¡æ³•æ¥è§¸/ç„¡æ³•å¤é¾';
    markerRemark.appendChild(opt);
  } else if (remark && !defaultOptions.includes(remark)) {
    // è™•ç†èˆŠçš„æˆ–è‡ªå®šç¾©çš„ remark æƒ…æ³
    const opt = document.createElement('option');
    opt.value = remark;
    opt.textContent = remark;
    markerRemark.appendChild(opt);
  }

  markerRemark.value = remark || '';

  // === æ–°å¢ï¼šç•¶ç‹€æ…‹è®Šæ›´æ™‚ï¼Œè‡ªå‹•ä¿å­˜ä¸¦é—œé–‰ç·¨è¼¯æ¬„ ===
  markerRemark.onchange = () => {
    if (app.selectedMarker) { // ç¢ºä¿æœ‰é¸ä¸­çš„æ¨™è¨˜
      const time = document.getElementById('markerTime').value; // ç²å–ç•¶å‰æ™‚é–“ä¸‹æ‹‰é¸å–®çš„å€¼
      const newRemark = markerRemark.value.trim();

      app.selectedMarker.data.time = time; // ä¿å­˜å®Œæ•´æ™‚é–“æ’ç¨‹å­—ä¸²
      app.selectedMarker.data.remark = newRemark;
      app.selectedMarker.setIcon(app.getCustomIcon(1, app.selectedMarker)); // æ›´æ–°æ¨™è¨˜åœ–æ¨™
      app.autoAssignTimeForRelatedMarkers(app.selectedMarker); // è‡ªå‹•åˆ†é…ç›¸é—œæ¨™è¨˜æ™‚é–“
      app.updateMarkerScales(); // æ›´æ–°æ‰€æœ‰æ¨™è¨˜çš„æ¯”ä¾‹å’Œé‚Šæ¡†
      app.saveMarkers(); // ä¿å­˜åˆ° localStorage

      // é—œé–‰ç·¨è¼¯æ¬„
      document.getElementById('markerEditModal').style.display = 'none';
      const infoPanel = document.getElementById('infoPanel');
      if (infoPanel) {
        infoPanel.style.display = 'block';
      }
      app.updateInfoPanel(app.selectedMarker.data); // æ›´æ–°è³‡è¨Šé¢æ¿
    }
  };
}

// === é¸æ“‡æœ€è¿‘çš„å…ˆå‰æ™‚é–“ (ç”¨æ–¼åœ°åœ–ä¸Šé¡¯ç¤ºçš„å€’æ•¸è¨ˆæ™‚) ===
function getNearestTimeString(marker) {
  let times = (marker.data.time || "").split(/\s+/).filter(Boolean);
  if (!times.length) return "";

  const now = new Date();
  const nowMinutes = now.getHours() * 60 + now.getMinutes();

  let minAbsDiff = Infinity;
  let bestDisplayTime = "";

  for (const t of times) {
    const m = t.match(/(\d{1,2}):(\d{2})/);
    if (!m) {
      console.warn(`Invalid time format: ${t}`);
      continue;
    }
    const h = parseInt(m[1], 10);
    const mm = parseInt(m[2], 10);
    const scheduleMinutes = h * 60 + mm;

    let diff = scheduleMinutes - nowMinutes; // è¨ˆç®—æ’ç¨‹æ™‚é–“èˆ‡ç•¶å‰æ™‚é–“çš„å·®å€¼ï¼ˆåˆ†é˜ï¼‰

    // è™•ç†è·¨åˆå¤œçš„æƒ…æ³ï¼Œä½¿æ™‚é–“å·®åœ¨ -12å°æ™‚ åˆ° +12å°æ™‚ä¹‹é–“
    if (diff > 12 * 60) {
      diff -= 24 * 60; // å¦‚æœå·®å€¼è¶…é12å°æ™‚ï¼Œå¾€å‰æ¨ä¸€å¤©
    } else if (diff < -12 * 60) {
      diff += 24 * 60; // å¦‚æœå·®å€¼å°æ–¼-12å°æ™‚ï¼Œå¾€å¾Œæ¨ä¸€å¤©
    }

    const absDiff = Math.abs(diff);

    // åªè€ƒæ…®çµ•å°æ™‚é–“å·®å°æ–¼æˆ–ç­‰æ–¼ 30 åˆ†é˜çš„æ™‚é–“
    if (absDiff <= 30) {
      if (absDiff < minAbsDiff) {
        minAbsDiff = absDiff;
        bestDisplayTime = t;
      }
    }
  }

  return bestDisplayTime;
}

class MapApp {
  constructor() {
    this.map = L.map('map', {
      doubleClickZoom: false
    });
    this.map.locate({ setView: true, maxZoom: 16 });

    this.userMarker = null;
    this.accuracyCircle = null;
    this.watchId = null;
    this.isTracking = false;

    this.map.on('locationfound', e => this.updateUserLocation(e));
    this.map.on('locationerror', () => {
      alert("ç„¡æ³•å–å¾—ä½ çš„å®šä½ï¼Œä½¿ç”¨é è¨­åœ°é»ã€‚");
      this.map.setView([3.0000, 101.6167], 14);
    });

    this.markers = new L.FeatureGroup();
    this.routeSelecting = false;
    this.selectedMarkers = [];

    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: 'Â© <a href="https://carto.com/">CARTO</a>'
    }).addTo(this.map);
    this.markers.addTo(this.map);

    this.initControls();
    this.loadSavedMarkers();
    this.initEventListeners();

    this.map.on('zoomend', () => this.updateMarkerScales());
    this.updateMarkerScales();

    // æ¯åˆ†é˜æ›´æ–°æ¨™è¨˜æ¯”ä¾‹ä»¥åæ˜ åŸºæ–¼æ™‚é–“çš„åœ–æ¨™è®ŠåŒ–
    setInterval(() => this.updateMarkerScales(), 60 * 1000);
  }

  initControls() {
    const control = L.control({ position: 'topright' });
    control.onAdd = () => {
      const div = L.DomUtil.create('div', 'leaflet-control-custom');
      div.innerHTML = `
        <div class="btn-row">
          <button onclick="app.toggleEditMode()" id="editBtn">é–‹å§‹ç·¨è¼¯</button>
        </div>
        <div class="btn-row">
          <button onclick="app.toggleTracking()" id="trackBtn">é–‹å•Ÿå³æ™‚å®šä½</button>
        </div>
        <div class="btn-row">
          <button onclick="app.confirmImportFromGitHub()">ğŸŒ åŒ¯å…¥ GitHub æ¨™è¨˜</button>
        </div>
        <div class="btn-row">
          <button onclick="app.toggleSelectingRoute()" id="routeBtn">é¸æ“‡è·¯ç·š</button>
          <button onclick="app.openGoogleRoute()">ğŸ—ºï¸ Google åœ°åœ–è·¯ç·š</button>
        </div>
      `;
      L.DomEvent.disableClickPropagation(div);
      return div;
    };
    control.addTo(this.map);
    this.currentMode = "done";
  }

  updateUserLocation(e) {
    const latlng = e.latlng;
    const maxRadius = 100;
    const radius = Math.min(e.accuracy / 2, maxRadius);

    if (!this.userMarker) {
      this.userMarker = L.marker(latlng, {
        icon: L.divIcon({
          className: '',
          html: '<div style="background: blue; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
          iconSize: [12, 12],
          iconAnchor: [6, 6]
        }),
        zIndexOffset: 1000
      }).addTo(this.map);
    } else {
      this.userMarker.setLatLng(latlng);
    }

    if (!this.accuracyCircle) {
      this.accuracyCircle = L.circle(latlng, {
        radius: radius,
        color: 'blue',
        fillOpacity: 0.2,
        weight: 1
      }).addTo(this.map);
    } else {
      this.accuracyCircle.setLatLng(latlng);
      this.accuracyCircle.setRadius(radius);
    }

    if (!this.isTracking) {
      this.map.setView(latlng, this.map.getZoom() || 16);
    }
  }

  toggleTracking() {
    this.isTracking = !this.isTracking;
    const trackBtn = document.getElementById('trackBtn');
    if (this.isTracking) {
      trackBtn.textContent = 'é—œé–‰å³æ™‚å®šä½';
      if (navigator.geolocation) {
        this.watchId = navigator.geolocation.watchPosition(
          (position) => {
            const e = {
              latlng: L.latLng(position.coords.latitude, position.coords.longitude),
              accuracy: position.coords.accuracy
            };
            this.updateUserLocation(e);
          },
          () => {
            alert('ç„¡æ³•å–å¾—ä½ çš„ä½ç½®ï¼Œè«‹æª¢æŸ¥å®šä½æ¬Šé™');
            this.stopTracking();
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
          }
        );
      } else {
        alert('ä½ çš„ç€è¦½å™¨ä¸æ”¯æ´åœ°ç†å®šä½');
        this.stopTracking();
      }
    } else {
      this.stopTracking();
    }
  }

  stopTracking() {
    if (this.watchId !== null) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
    }
    this.isTracking = false;
    const trackBtn = document.getElementById('trackBtn');
    if (trackBtn) trackBtn.textContent = 'é–‹å•Ÿå³æ™‚å®šä½';
  }

  updateInfoPanel(data) {
    const infoPanel = document.getElementById('infoPanel');
    if (!infoPanel) {
      console.error('Info panel element not found in DOM');
      return;
    }
    const displayRemark = data.remark === 'f' ? 'ç„¡æ³•æ¥è§¸/ç„¡æ³•å¤é¾' : (data.remark || '');
    const content = `
      <p>æ™‚é–“ï¼š${data.time || ''}</p>
      <p>å‚™è¨»ï¼š${displayRemark}</p>
      <p>åº§æ¨™ï¼š${data.lat ? data.lat.toFixed(6) : ''}, ${data.lng ? data.lng.toFixed(6) : ''}</p>
      <p>åœ°åœ–ç·¨è™Ÿï¼š${data.mapId !== undefined ? data.mapId : ''}</p>
      <p>åœ°å›¾ç¸½æ¡é›†é»ï¼š${data.totalPoints !== undefined ? data.totalPoints : ''}</p>
    `;
    document.getElementById('panelContent').innerHTML = content;
    infoPanel.style.display = 'block';
    console.log('Info panel updated with data:', data);
  }

  initEventListeners() {
    // æ²’æœ‰é»æ“Š/é›™æ“Šæ·»åŠ æ¨™è¨˜çš„åŠŸèƒ½
  }

  getCustomIcon(scale = 1, marker = null, orderNumber = null) {
    let iconUrl = 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/gather.png';
    // é è¨­å¤é¾åœ–æ¨™ (éè—è‰²)
    const defaultElderIconUrl = 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/elder.png';

    // æª¢æŸ¥æ¨™è¨˜æ˜¯å¦æœ‰å‚™è¨»ä¸”ä¸æ˜¯ 'f' ä¸”åŒ…å« 'ç¢ºèª'
    if (marker && marker.data && marker.data.remark && !marker.data.remark.toLowerCase().includes('f')) {
      const remark = marker.data.remark;
      const times = (marker.data.time || "").split(/\s+/).filter(Boolean);

      // åªæœ‰ç•¶æœ‰æ™‚é–“ä¸”å‚™è¨»æ˜¯ç¢ºèªæ¨¡å¼æ™‚æ‰æ‡‰ç”¨å¤é¾é‚è¼¯
      if (times.length && remark.includes('ç¢ºèª')) {
        const now = new Date();
        const nowMin = now.getHours() * 60 + now.getMinutes();
        const bufferMinutes = 9; // æå‰é¡¯ç¤ºåœ–æ¨™çš„ç·©è¡æ™‚é–“

        let currentSlot = -1;
        for (let i = 0; i < times.length; i++) {
          const [h, m] = times[i].split(':').map(Number);
          const timeMin = h * 60 + m;

          let displayWindowStartMin = timeMin - bufferMinutes;
          // è™•ç†è·¨åˆå¤œçš„æ™‚é–“èµ·å§‹é»
          if (displayWindowStartMin < 0) displayWindowStartMin += 24 * 60;

          const nextTime = times[i + 1] || times[0];
          const [nh, nm] = nextTime.split(':').map(Number);
          let nextTimeMin = nh * 60 + nm;
          // å¦‚æœä¸‹ä¸€å€‹æ™‚é–“æ¯”ç•¶å‰æ™‚é–“å°ï¼ˆä»£è¡¨è·¨åˆå¤œäº†ï¼‰ï¼Œå‰‡åŠ ä¸Š24å°æ™‚çš„åˆ†é˜æ•¸
          if (nextTimeMin < timeMin) nextTimeMin += 24 * 60;

          // æª¢æŸ¥ç•¶å‰æ™‚é–“æ˜¯å¦è½åœ¨é€™å€‹æ™‚æ®µçš„æ´»èºçª—å£å…§
          let isNowWithinWindow = false;
          if (displayWindowStartMin <= nextTimeMin) {
            isNowWithinWindow = (nowMin >= displayWindowStartMin && nowMin < nextTimeMin);
          } else { // çª—å£è·¨åˆå¤œ (ä¾‹å¦‚ 23:00 åˆ° 01:00)
            isNowWithinWindow = (nowMin >= displayWindowStartMin || nowMin < nextTimeMin);
          }

          if (isNowWithinWindow) {
            currentSlot = i;
            break;
          }
        }

        if (currentSlot >= 0) {
          const patternMatch = remark.match(/([?AB\s]+)ç¢ºèª/);
          if (patternMatch) {
            const pattern = patternMatch[1].trim().split(/\s+/);
            const patternLength = pattern.length;
            const slotState = pattern[currentSlot % patternLength];

            if (slotState === 'A') {
              iconUrl = defaultElderIconUrl; // è¨­å®šç‚ºé è¨­å¤é¾
            } else if (slotState === 'B') {
              iconUrl = 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/blueelder.png'; // è¨­å®šç‚ºè—è‰²å¤é¾
            } else if (slotState === '?') {
              // å¦‚æœæ˜¯ '?'ï¼Œå‰‡ä¸é¡¯ç¤ºå¤é¾åœ–æ¨™ï¼Œä¿æŒç‚º gather.png
              iconUrl = 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/gather.png';
            }
            // å¦‚æœ slotState æ˜¯å…¶ä»–æœªæ˜ç¢ºè™•ç†çš„å­—ç¬¦ï¼ŒiconUrl ä¿æŒ gather.png æˆ–ä¹‹å‰çš„å€¼
          }
        }
      }
    }

    let size = 40 * scale;
    // ä½¿ç”¨æ–°çš„ getNearestTimeStringï¼Œå®ƒæœƒæ ¹æ“š30åˆ†é˜è¦å‰‡è¿”å›ç©ºå­—ä¸²æˆ–æ™‚é–“
    let timeStr = getNearestTimeString(marker || { data: {} });
    let timeFontSize = Math.max(10, Math.floor(14 * scale));
    let showRedCross = marker && marker.data && typeof marker.data.remark === 'string' && marker.data.remark.toLowerCase().includes('f');

    const redCrossSVG = `
      <svg width="${size}" height="${size}" style="position:absolute;top:0;left:0;pointer-events:none;z-index:11;" viewBox="0 0 ${size} ${size}">
        <line x1="6" y1="6" x2="${size-6}" y2="${size-6}" stroke="rgba(255,0,0,0.3)" stroke-width="6" stroke-linecap="round"/>
        <line x1="${size-6}" y1="6" x2="6" y2="${size-6}" stroke="rgba(255,0,0,0.3)" stroke-width="6" stroke-linecap="round"/>
      </svg>
    `;

    return L.divIcon({
      className: '',
      html: `
        <div class="marker-wrapper" style="position:relative;">
          <div class="marker-border" style="
            background-image: url('${iconUrl}');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: ${size}px;
            height: ${size}px;
            position: relative;
          ">
            ${showRedCross ? redCrossSVG : ""}
            ${timeStr ? `<div style="position:absolute;bottom:-18px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.75);color:#fff;font-size:${timeFontSize}px;padding:2px 8px;border-radius:4px;white-space:nowrap;">${timeStr}</div>` : ""}
            ${orderNumber !== null ? `
              <div class="marker-order-badge" style="
                position: absolute;
                top: ${-10 * scale}px;
                left: ${-10 * scale}px;
                width: ${Math.max(20 * scale, 18)}px;
                height: ${Math.max(20 * scale, 18)}px;
                background: #ff6600;
                color: #fff;
                border-radius: 50%;
                font-size: ${Math.max(11 * scale, 12)}px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                border: ${2 * scale}px solid #fff;
                z-index: 20;
              ">${orderNumber+1}</div>
            ` : ""}
          </div>
        </div>`,
      iconSize: [size, size],
      iconAnchor: [size / 2, size / 2],
      popupAnchor: [0, -size / 2]
    });
  }

  isMobile() {
    return /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
  }

  updateMarkerScales() {
    const zoom = this.map.getZoom();
    const mobile = this.isMobile();
    let scale = 1.0;
    if (mobile) {
      if (zoom >= 18) scale = 2.0;
      else if (zoom === 17) scale = 1.6;
      else if (zoom === 16) scale = 1.2;
      else if (zoom === 15) scale = 1.0;
      else if (zoom === 14) scale = 0.6;
      else scale = 0.3;
    } else {
      if (zoom >= 18) scale = 1.0;
      else if (zoom === 17) scale = 0.9;
      else if (zoom === 16) scale = 0.8;
      else if (zoom === 15) scale = 0.5;
      else if (zoom === 14) scale = 0.3;
      else scale = 0.3;
    }
    this.markers.eachLayer(marker => {
      let orderNumber = null;
      if (this.routeSelecting) {
        const idx = this.selectedMarkers.indexOf(marker);
        if (idx !== -1) orderNumber = idx;
      }
      marker.setIcon(this.getCustomIcon(scale, marker, orderNumber));
      const el = marker.getElement();
      if (el && this.selectedMarkers.includes(marker)) {
        el.classList.add('markerBorder');
      } else if (el) {
        el.classList.remove('markerBorder');
      }
    });
    document.getElementById('zoomDisplay').textContent = `Zoom: ${zoom}`;
  }

  addMarker(latlng, data) {
    if (!data.totalPoints) data.totalPoints = 1;
    if (!data.mapId) data.mapId = 1;
    if (!data.remark) data.remark = '';
    data.type = 0;
    const marker = L.marker(latlng, {
      icon: this.getCustomIcon(1, { data }),
      draggable: false
    });
    marker.data = data;
    this.resetAllMarkers();
    let tapped = false;
    const handler = (e) => {
      console.log('Marker clicked/tapped:', data);
      if (tapped) return;
      tapped = true;
      setTimeout(() => tapped = false, 300);
      this.selectedMarker = marker;
      if (this.routeSelecting) {
        console.log('Route selecting mode, toggling marker selection');
        const markerElement = marker.getElement();
        if (this.selectedMarkers.includes(marker)) {
          this.selectedMarkers = this.selectedMarkers.filter(m => m !== marker);
          if (markerElement) markerElement.classList.remove('markerBorder');
        } else {
          this.selectedMarkers.push(marker);
          if (markerElement) markerElement.classList.add('markerBorder');
        }
        this.updateMarkerScales();
        return;
      }
      if (this.currentMode === "editMarker") {
        console.log('Edit mode, showing edit modal');
        this.resetAllMarkers();
        marker.setOpacity(1.0);
        marker.setZIndexOffset(1000);
        setTimeout(() => {
          const infoPanel = document.getElementById('infoPanel');
          if (infoPanel) {
            console.log('Hiding info panel for edit mode');
            infoPanel.style.display = 'none';
          }
          // æ›´æ–°æ™‚é–“é¸é …ï¼Œä¸¦åœ¨é¸ä¸­æ™‚è‡ªå‹•æ›´æ–°æ™‚é–“æ®µ
          updateTimeOptionsForEdit(marker.data.totalPoints || 1, marker.data.time);
          // æ›´æ–°å‚™è¨»é¸é … (ç¾åœ¨å®ƒæœƒè‡ªå‹•ä¿å­˜ä¸¦é—œé–‰å½ˆçª—)
          updateRemarkOptionsForEdit(marker.data.remark);
          
          document.getElementById('markerEditModal').style.display = 'block';
          // ç§»é™¤ saveMarkerBtn çš„ onclick è™•ç†ï¼Œå› ç‚ºä¿å­˜ç¾åœ¨ç”± remark çš„ onchange è§¸ç™¼
          document.getElementById('saveMarkerBtn').onclick = null; 
        }, 0);
      } else {
        console.log('Normal mode, updating info panel');
        this.resetAllMarkers();
        marker.setOpacity(1.0);
        marker.setZIndexOffset(1000);
        this.updateInfoPanel(marker.data);
      }
    };
    marker.on('click', handler);
    marker.on('touchstart', handler);
    this.selectedMarker = marker;
    this.markers.addLayer(marker);
    this.saveMarkers();
    this.updateMarkerScales();
  }

  resetAllMarkers() {
    this.markers.eachLayer(m => {
      m.setOpacity(0.6);
      m.setZIndexOffset(0);
    });
  }

  autoAssignTimeForRelatedMarkers(marker) {
    const totalPoints = marker.data.totalPoints;
    if (![2, 3, 4, 5, 6].includes(totalPoints)) return;

    const selectedTime = marker.data.time;
    const selectedMapId = marker.data.mapId;
    const timeOptions = timeTableByTotalPoints[totalPoints];
    const selectedTimeIndex = timeOptions.indexOf(selectedTime);

    if (selectedTimeIndex === -1) {
      console.warn('Invalid time selected for marker:', selectedTime);
      return;
    }

    let relatedMarkers = [];
    this.markers.eachLayer(m => {
      if (m !== marker && m.data.mapId === selectedMapId && m.data.totalPoints === totalPoints) {
        relatedMarkers.push(m);
      }
    });

    const maxRelated = totalPoints - 1;
    if (relatedMarkers.length > maxRelated) {
      alert(`è­¦å‘Šï¼šæ‰¾åˆ°å¤šå€‹å…·æœ‰ç›¸åŒ mapId å’Œ totalPoints=${totalPoints} çš„æ¨™è¨˜ï¼Œåªæ›´æ–°å‰ ${maxRelated} å€‹ã€‚`);
      relatedMarkers = relatedMarkers.slice(0, maxRelated);
    }

    const usedIndices = [selectedTimeIndex];
    relatedMarkers.forEach(m => {
      const idx = timeOptions.indexOf(m.data.time);
      if (idx !== -1) usedIndices.push(idx);
    });

    if (usedIndices.length >= maxRelated && relatedMarkers.length >= maxRelated) {
      const availableIndices = Array.from({ length: timeOptions.length }, (_, i) => i).filter(i => !usedIndices.includes(i));
      if (availableIndices.length > 0) {
        const nthMarker = relatedMarkers.find(m => !usedIndices.includes(timeOptions.indexOf(m.data.time)) || timeOptions.indexOf(m.data.time) === -1) ||
                           relatedMarkers[relatedMarkers.length - 1];
        if (nthMarker) {
          nthMarker.data.time = timeOptions[availableIndices[0]];
          nthMarker.setIcon(this.getCustomIcon(1, nthMarker));
          if (this.selectedMarker === nthMarker) {
            this.updateInfoPanel(nthMarker.data);
          }
        }
      }
    }
  }

  saveMarkers() {
    const saved = [];
    this.markers.eachLayer(marker => saved.push({ ...marker.data, lat: marker.getLatLng().lat, lng: marker.getLatLng().lng }));
    localStorage.setItem('mhnow_markers', JSON.stringify(saved));
  }

  loadSavedMarkers() {
    this.markers.clearLayers();
    const saved = JSON.parse(localStorage.getItem('mhnow_markers') || '[]');
    saved.forEach(data => {
      if (data.totalPoints === 1) {
        // å¦‚æœæ‚¨å¸Œæœ›å–®é»æ¨™è¨˜ç¸½æ˜¯è‡ªå‹•è¨­å®šä¸€å€‹é è¨­æ™‚é–“ï¼Œè«‹å–æ¶ˆè¨»è§£ä¸‹é¢é€™è¡Œ
        // data.time = timeTableByTotalPoints[1][0];
      }
      delete data.name;
      data.type = 0;
      this.addMarker(L.latLng(data.lat, data.lng), data);
    });
    this.updateMarkerScales();
  }

  confirmImportFromGitHub() {
    if (confirm('ç¢ºå®šå¾ GitHub åŒ¯å…¥æ¨™è¨˜ï¼Ÿé€™å°‡è¦†è“‹ç¾æœ‰æ¨™è¨˜ã€‚')) {
      if (confirm('å†æ¬¡ç¢ºèªï¼šçœŸçš„è¦å¾ GitHub åŒ¯å…¥ä¸¦è¦†è“‹ï¼Ÿ')) {
        this.importFromGitHub();
      }
    }
  }

  importFromGitHub() {
    const url = 'https://raw.githubusercontent.com/kinbak1115/mh-map/main/mhnow_backup_2025-05-12.json';
    fetch(url)
      .then(res => res.json())
      .then(data => {
        if (!Array.isArray(data)) throw new Error();
        data.forEach(item => {
          delete item.name;
          item.type = 0;
        });
        localStorage.setItem('mhnow_markers', JSON.stringify(data));
        alert('æˆåŠŸå¾ GitHub åŒ¯å…¥æ¨™è¨˜ï¼Œé‡æ–°è¼‰å…¥åœ°åœ–ã€‚');
        location.reload();
      })
      .catch(() => alert('GitHub åŒ¯å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆé€£çµèˆ‡æ ¼å¼ã€‚'));
  }

  toggleEditMode() {
    if (this.routeSelecting) {
      this.clearAllMarkerBorders();
      this.routeSelecting = false;
      const routeBtn = document.getElementById('routeBtn');
      if (routeBtn) routeBtn.textContent = 'é¸æ“‡è·¯ç·š';
    }
    if (this.currentMode === "done") {
      this.currentMode = "editMarker";
      document.getElementById('editBtn').textContent = "çµæŸç·¨è¼¯";
    } else {
      this.currentMode = "done";
      document.getElementById('editBtn').textContent = "é–‹å§‹ç·¨è¼¯";
      this.saveMarkers();
      document.getElementById('markerEditModal').style.display = 'none';
      const infoPanel = document.getElementById('infoPanel');
      if (infoPanel) {
        console.log('Restoring info panel after ending edit mode');
        infoPanel.style.display = 'block';
      }
    }
    this.updateMarkerScales();
  }

  toggleSelectingRoute() {
    this.routeSelecting = !this.routeSelecting;
    const button = document.getElementById('routeBtn');
    if (this.routeSelecting) {
      if (this.currentMode !== 'done') {
        this.currentMode = 'done';
        const editBtn = document.getElementById('editBtn');
        if (editBtn) editBtn.textContent = 'é–‹å§‹ç·¨è¼¯';
        document.getElementById('markerEditModal').style.display = 'none';
        const infoPanel = document.getElementById('infoPanel');
        if (infoPanel) {
          console.log('Restoring info panel after ending edit mode for route selection');
          infoPanel.style.display = 'block';
        }
      }
      this.selectedMarkers = [];
      button.textContent = 'å®Œæˆé¸æ“‡';
      this.resetAllMarkers();
    } else {
      this.clearAllMarkerBorders();
      button.textContent = 'é¸æ“‡è·¯ç·š';
    }
    this.updateMarkerScales();
  }

  clearAllMarkerBorders() {
    this.markers.eachLayer(marker => {
      const markerElement = marker.getElement();
      if (markerElement) {
        markerElement.classList.remove('markerBorder');
      }
    });
    this.selectedMarkers = [];
  }

  openGoogleRoute() {
    if (!this.selectedMarkers.length) {
      alert("è«‹å…ˆé¸æ“‡è‡³å°‘ä¸€å€‹æ¨™è¨˜");
      return;
    }
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const current = `${position.coords.latitude},${position.coords.longitude}`;
        const waypoints = this.selectedMarkers.map(m => `${m.getLatLng().lat},${m.getLatLng().lng}`);
        const route = [current, ...waypoints];
        const url = `https://www.google.com/maps/dir/${route.join('/')}`;
        const link = document.createElement('a');
        link.href = url;
        link.target = '_blank';
        link.click();
      },
      () => alert('ç„¡æ³•å–å¾—ä½ çš„ä½ç½®ï¼Œè«‹é–‹å•Ÿå®šä½æ¬Šé™')
    );
  }
}

document.addEventListener('DOMContentLoaded', function() {
  // é é¢è¼‰å…¥æ™‚ä¸éœ€è¦é è¨­èª¿ç”¨ updateTimeOptionsForEditï¼Œå› ç‚ºå®ƒæœƒåœ¨é»æ“Šæ¨™è¨˜æ™‚è™•ç†
});

const app = new MapApp();
</script>
</body>
</html>
