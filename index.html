<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>MH Now å¤é¾è¨˜éŒ„åœ°åœ– - è’²ç§</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <style>
    body, html { margin: 0; padding: 0; }
    #map { height: 100vh; }
    .leaflet-control-custom {
      background: white;
      padding: 10px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.4);
      font-size: 16px;
      width: 240px;
      box-sizing: border-box;
    }
    .leaflet-control-custom .btn-row {
      display: flex;
      gap: 6px;
      margin-bottom: 6px;
    }
    .leaflet-control-custom button {
      flex: 1;
      font-size: 18px;
      padding: 10px;
      box-sizing: border-box;
    }
    select[multiple] {
      width: 100%;
      font-size: 18px;
      padding: 6px;
      margin-bottom: 10px;
    }
    @media (max-width: 600px) {
      .leaflet-control-custom {
        width: 100%;
        font-size: 18px;
      }
      .leaflet-control-custom button {
        font-size: 28px;
        padding: 18px;
        min-height: 48px;
      }
      select[multiple], select, input[type="number"] {
        font-size: 24px;
        padding: 12px;
      }
    }
    .marker-wrapper {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .marker-border {
      border-radius: 50%;
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center;
    }
    .markerBorder {
      box-shadow: 0 0 0 6px red;
      border-radius: 50%;
      box-sizing: border-box;
    }
    #version, #zoomDisplay {
      position: absolute;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      font-size: 16px;
      border-radius: 5px;
      z-index: 1000;
    }
    #version { bottom: 10px; }
    #zoomDisplay { bottom: 40px; }
    .info-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 220px;
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      font-size: 16px;
      z-index: 1000;
    }
    .info-panel h3 {
      margin: 0 0 8px;
      font-size: 18px;
      border-bottom: 1px solid #ccc;
    }
    .info-panel p {
      margin: 8px 0;
    }
    .leaflet-popup-content { display: none; }
  </style>
</head>
<body>

<!-- ğŸŸ¦ Marker ç·¨è¼¯ç”¨ Modalï¼ˆé¡¯ç¤ºåœ¨å·¦ä¸Šè§’ï¼‰ -->
<div id="markerEditModal" style="
  display:none;
  position:fixed;
  top: 20px;
  left: 20px;
  background: #fff;
  border: 1px solid #ccc;
  padding: 24px 32px;
  z-index: 10000;
  box-shadow: 0 2px 15px rgba(0,0,0,0.4);
  border-radius: 10px;
  width: 200px;
  font-size: 16px;
  line-height: 1.4;
">
  <h3 style="margin-top: 0; font-size: 22px;">æ›´æ”¹æ¨™è¨˜è³‡è¨Š</h3>
  <label for="markerName">åç¨±ï¼š</label>
  <select id="markerName" style="width: 100%; font-size: 16px; padding: 12px;">
    <option value="å…¨å¤©å¤é¾ç¨®">å…¨å¤©å¤é¾ç¨®</option>
    <option value="ABABå¤é¾ç¨®">ABABå¤é¾ç¨®</option>
    <option value="BABAå¤é¾ç¨®">BABAå¤é¾ç¨®</option>
    <option value="å¤§é€£ç‹©çµ">å¤§é€£ç‹©çµ</option>
  </select><br/><br/>
  <label for="markerTime">æ™‚é–“ï¼š</label>
  <select id="markerTime" style="width: 100%; font-size: 16px; padding: 12px;">
    <!-- ç”± JS å‹•æ…‹ç”¢ç”Ÿ -->
  </select><br/><br/>
  <label for="markerType">é¡è‰²ï¼š</label>
  <select id="markerType" style="width: 100%; font-size: 16px; padding: 12px;">
    <option value="0">âšª åŸå§‹</option>
    <option value="1">ğŸ”´ ç´…</option>
    <option value="2">ğŸ”µ è—</option>
    <option value="3">ğŸŸ¢ ç¶ </option>
    <option value="4">ğŸŸ£ ç´«</option>
  </select><br/><br/>
  <label for="markerRemark">ç‹€æ…‹ï¼š</label>
  <select id="markerRemark" style="width: 100%; font-size: 16px; padding: 12px;">
    <option value="Aç¢ºèª">Aç¢ºèª</option>
    <option value="Bç¢ºèª">Bç¢ºèª</option>
    <option value="ABç¢ºèª">ABç¢ºèª</option>
  </select><br/><br/>
  <div style="text-align:right;">
    <button id="saveMarkerBtn" style="font-size: 16px; padding: 8px 16px;">å„²å­˜</button>
    <button onclick="
      document.getElementById('markerEditModal').style.display='none';
      const infoPanel = document.getElementById('infoPanel');
      if (infoPanel) infoPanel.style.display = '';
    " style="font-size: 16px; padding: 8px 16px; margin-left: 12px;">å–æ¶ˆ</button>
  </div>
</div>

<div id="map"></div>
<div id="infoPanel" class="info-panel">
  <h3>æ¨™è¨˜è³‡è¨Š</h3>
  <div id="panelContent">è«‹é»é¸åœ°åœ–ä¸Šçš„æ¨™è¨˜</div>
</div>
<div id="version">ç‰ˆæœ¬ 4.1.2</div>
<div id="zoomDisplay">Zoom: -</div>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script>
// æ‰€æœ‰æ™‚é–“è¡¨
const timeTableByTotalPoints = {
  1: [
    "06:15 07:05 07:55 08:45 09:35 10:25 11:15 12:05 12:55 13:45 14:35 15:25 16:15 17:05 17:55 18:45 19:35 20:25 21:15 22:05",
  ],
  2: [
    "06:15 07:55 08:45 09:35 10:25 11:15 12:05 12:55 13:45 14:35 15:25 16:15 17:05 17:55 18:45 19:35 20:25 21:15 22:05 22:55",
    "06:40 08:20 09:10 10:00 10:50 11:40 12:30 13:20 14:10 15:00 15:50 16:40 17:30 18:20 19:10 20:00 20:50 21:40 22:30"
  ],
  3: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:55 10:25 12:55 15:25 17:55 20:25"
  ],
  4: [
    "06:15 07:55 09:35 11:15 12:55 14:35 16:15 17:55 19:35 21:15 22:55",
    "06:40 08:20 10:00 11:40 13:20 15:00 16:40 18:20 20:00 21:40 23:20",
    "07:05 08:45 10:25 12:05 13:45 15:25 17:05 18:45 20:25 22:05",
    "07:30 09:10 10:50 12:30 14:10 15:50 17:30 19:10 20:50 22:30"
  ],
  5: [
    "06:15 08:20 10:25 12:30 14:35 16:40 18:45 20:50 22:55",
    "06:40 08:45 10:50 12:55 15:00 17:05 19:10 21:15 23:20",
    "07:05 09:10 11:15 13:20 15:25 17:30 19:35 21:40",
    "07:30 09:35 11:40 13:45 15:50 17:55 20:00 22:05",
    "07:55 10:00 12:05 14:10 16:15 18:20 20:25 22:30"
  ],
  6: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "06:40 09:10 11:40 14:10 16:40 19:10 21:40",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:30 10:00 12:30 15:00 17:30 20:00 22:30",
    "07:55 10:25 12:55 15:25 17:55 20:25 22:55",
    "08:20 10:50 13:20 15:50 18:20 20:50 23:20"
  ],
  7: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "06:40 09:10 11:40 14:10 16:40 19:10 21:40",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:30 10:00 12:30 15:00 17:30 20:00 22:30",
    "07:55 10:25 12:55 15:25 17:55 20:25 22:55",
    "08:20 10:50 13:20 15:50 18:20 20:50 23:20"
  ],
  8: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "06:40 09:10 11:40 14:10 16:40 19:10 21:40",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:30 10:00 12:30 15:00 17:30 20:00 22:30",
    "07:55 10:25 12:55 15:25 17:55 20:25 22:55",
    "08:20 10:50 13:20 15:50 18:20 20:50 23:20"
  ]
};

const markerColors = { 0: '', 1: 'red', 2: 'blue', 3: 'green', 4: 'purple' };

// æ‰€æœ‰38ç¨®æ™‚æ®µ
const allTimes = [
  "06:15", "06:40", "07:05", "07:30",
  "07:55", "08:20", "08:45", "09:10",
  "09:35", "10:00", "10:25", "10:50",
  "11:15", "11:40", "12:05", "12:30",
  "12:55", "13:20", "13:45", "14:10",
  "14:35", "15:00", "15:25", "15:50",
  "16:15", "16:40", "17:05", "17:30",
  "17:55", "18:20", "18:45", "19:10",
  "19:35", "20:00", "20:25", "20:50",
  "21:15", "21:40", "22:05", "22:30",
  "22:55", "23:20"
];

// === æ™‚é–“é¸é …ç”Ÿæˆ ===
function updateTimeOptionsForEdit(totalPoints, selectedTime) {
  const markerTime = document.getElementById('markerTime');
  markerTime.innerHTML = '';
  const arr = timeTableByTotalPoints[totalPoints] || [];
  arr.forEach(timestr => {
    const opt = document.createElement('option');
    opt.value = timestr;
    opt.textContent = timestr;
    markerTime.appendChild(opt);
  });
  // å¦‚æœ totalPoints=1ï¼Œè‡ªå‹•é¸æ“‡å”¯ä¸€çš„æ™‚é–“é¸é …
  if (totalPoints === 1 && arr.length === 1) {
    markerTime.value = arr[0];
  } else if (selectedTime) {
    markerTime.value = selectedTime;
  }
}

// é¸æ“‡æœ€è¿‘çš„å…ˆå‰æ™‚é–“ï¼ˆç§»é™¤25åˆ†é˜é™åˆ¶ï¼‰
function getNearestTimeString(marker) {
  // Get the full time schedule from marker.data.time
  let times = (marker.data.time || "").split(/\s+/).filter(Boolean);
  if (!times.length) return "";

  // Get current time in local time zone (assumed Asia/Kuala_Lumpur)
  const now = new Date();
  const nowMin = now.getHours() * 60 + now.getMinutes();

  let minDiff = Infinity;
  let bestDisplayTime = "";

  // Find the closest previous time
  for (const t of times) {
    const m = t.match(/(\d{1,2}):(\d{2})/);
    if (!m) continue;
    const h = parseInt(m[1], 10);
    const mm = parseInt(m[2], 10);
    const total = h * 60 + mm;
    let diff = nowMin - total; // Positive diff means time is in the past
    // Handle times crossing midnight
    if (diff < -12 * 60) diff += 24 * 60;
    // Only consider past times (or exact match)
    if (diff >= 0 && diff < minDiff) {
      minDiff = diff;
      bestDisplayTime = t;
    }
  }

  return bestDisplayTime;
}

class MapApp {
  constructor() {
    this.map = L.map('map', {
      doubleClickZoom: false
    });
    this.map.locate({ setView: true, maxZoom: 16 });

    this.map.on('locationfound', e => {
      let maxRadius = 100;
      let r = Math.min(e.accuracy / 2, maxRadius);
      L.circle(e.latlng, {
        radius: r,
        color: 'blue',
        fillOpacity: 0.2
      }).addTo(this.map);
    });

    this.map.on('locationerror', () => {
      alert("ç„¡æ³•å–å¾—ä½ çš„å®šä½ï¼Œä½¿ç”¨é è¨­åœ°é»ã€‚");
      this.map.setView([3.0000, 101.6167], 14);
    });

    this.markers = new L.FeatureGroup();
    this.filteredTypes = [];
    this.lastMarkerType = 0;
    this.routeSelecting = false;
    this.selectedMarkers = [];

    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: 'Â© <a href="https://carto.com/">CARTO</a>'
    }).addTo(this.map);
    this.markers.addTo(this.map);

    this.initControls();
    this.loadSavedMarkers();
    this.initEventListeners();

    this.map.on('zoomend', () => this.updateMarkerScales());
    this.updateMarkerScales();

    setInterval(() => this.updateMarkerScales(), 60 * 1000);
  }

  initControls() {
    const control = L.control({ position: 'topright' });
    control.onAdd = () => {
      const div = L.DomUtil.create('div', 'leaflet-control-custom');
      div.innerHTML = `
        <div class="btn-row">
          <button onclick="app.toggleEditMode()" id="editBtn">é–‹å§‹ç·¨è¼¯</button>
          <button onclick="app.deleteSelectedMarker()">ğŸ—‘ï¸ åˆªé™¤æ¨™è¨˜</button>
        </div>
        <label>é¡¯ç¤ºé¡è‰²ï¼š</label>
        <select id="filterSelect" multiple size="5" onchange="app.filterMarkersByTypes()">
          <option value="0">âšª åŸå§‹</option>
          <option value="1">ğŸ”´ ç´…</option>
          <option value="2">ğŸ”µ è—</option>
          <option value="3">ğŸŸ¢ ç¶ </option>
          <option value="4">ğŸŸ£ ç´«</option>
        </select>
        <div class="btn-row">
          <button onclick="app.confirmImportFromGitHub()">ğŸŒ åŒ¯å…¥ GitHub æ¨™è¨˜</button>
        </div>
        <div class="btn-row">
          <button onclick="app.toggleSelectingRoute()" id="routeBtn">é¸æ“‡è·¯ç·š</button>
          <button onclick="app.openGoogleRoute()">ğŸ—ºï¸ Google åœ°åœ–è·¯ç·š</button>
        </div>
      `;
      L.DomEvent.disableClickPropagation(div);
      return div;
    };
    control.addTo(this.map);
    this.currentMode = "done";
  }

  updateInfoPanel(data) {
    const content = `
      <p><strong>${data.name}</strong></p>
      <p>æ™‚é–“ï¼š${data.time}</p>
      <p>é¡å‹ï¼š${markerColors[data.type] || 'åŸå§‹'}</p>
      <p>å‚™è¨»ï¼š${data.remark}</p>
      <p>åº§æ¨™ï¼š${data.lat ? data.lat.toFixed(6) : ""}, ${data.lng ? data.lng.toFixed(6) : ""}</p>
      <p>åœ°åœ–ç·¨è™Ÿï¼š${data.mapId !== undefined ? data.mapId : ""}</p>
      <p>åœ°å›¾æ€»é‡‡é›†ç‚¹ï¼š${data.totalPoints !== undefined ? data.totalPoints : ""}</p>
    `;
    document.getElementById('panelContent').innerHTML = content;
  }

  initEventListeners() {
    let mapTapped = false;
    const handleMapTap = (e) => {
      if (mapTapped) return;
      mapTapped = true;
      setTimeout(() => (mapTapped = false), 300);
      if (this.currentMode === "editMarker") {
        this.showMarkerForm(e.latlng);
      }
    };
    this.map.on("click", handleMapTap);
    this.map.on("touchstart", handleMapTap);
  }

  getCustomIcon(type = 0, scale = 1, marker = null, orderNumber = null) {
    const iconUrl = 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/gather.png';
    const iconUrls = {
      0: iconUrl,
      1: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/redelder.png',
      2: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/blueelder.png',
      3: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/greenelder.png',
      4: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/elder.png',
      raid: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/raid.png'
    };

    let useIconUrl = iconUrls[type];
    let isRaid = false;
    if (marker && marker.data && marker.data.name === "å¤§é€£ç‹©çµ") {
      useIconUrl = iconUrls.raid;
      isRaid = true;
    }

    let size = 40 * scale;
    if (isRaid) {
      size = size * 0.75;
    }

    let timeStr = "";
    if (marker) {
      if (!(marker.data && marker.data.name === "å¤§é€£ç‹©çµ")) {
        timeStr = getNearestTimeString(marker);
      }
    }

    let timeFontSize = Math.max(10, Math.floor(14 * scale));

    let showRedCross = marker && marker.data && typeof marker.data.remark === 'string' && marker.data.remark.toLowerCase().includes('f');

    const redCrossSVG = `
      <svg width="${size}" height="${size}" style="position:absolute;top:0;left:0;pointer-events:none;z-index:11;" viewBox="0 0 ${size} ${size}">
        <line x1="6" y1="6" x2="${size-6}" y2="${size-6}" stroke="rgba(255,0,0,0.3)" stroke-width="6" stroke-linecap="round"/>
        <line x1="${size-6}" y1="6" x2="6" y2="${size-6}" stroke="rgba(255,0,0,0.3)" stroke-width="6" stroke-linecap="round"/>
      </svg>
    `;

    return L.divIcon({
      className: '',
      html: `
        <div class="marker-wrapper" style="position:relative;">
          <div class="marker-border" style="
            background-image: url('${useIconUrl}');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: ${size}px;
            height: ${size}px;
            position: relative;
          ">
            ${showRedCross ? redCrossSVG : ""}
            ${timeStr ? `<div style="position:absolute;bottom:-18px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.75);color:#fff;font-size:${timeFontSize}px;padding:2px 8px;border-radius:4px;white-space:nowrap;">${timeStr}</div>` : ""}
            ${orderNumber !== null ? `
              <div class="marker-order-badge" style="
                position: absolute;
                top: ${-10 * scale}px;
                left: ${-10 * scale}px;
                width: ${Math.max(20 * scale, 18)}px;
                height: ${Math.max(20 * scale, 18)}px;
                background: #ff6600;
                color: #fff;
                border-radius: 50%;
                font-size: ${Math.max(11 * scale, 12)}px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                border: ${2 * scale}px solid #fff;
                z-index: 20;
              ">${orderNumber+1}</div>
            ` : ""}
          </div>
        </div>`,
      iconSize: [size, size],
      iconAnchor: [size / 2, size / 2],
      popupAnchor: [0, -size / 2]
    });
  }

  isMobile() {
    return /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
  }

  updateMarkerScales() {
    const zoom = this.map.getZoom();
    const mobile = this.isMobile();
    let scale = 1.0;
    if (mobile) { 
      if (zoom >= 18) scale = 2.0;
      else if (zoom === 17) scale = 1.6;
      else if (zoom === 16) scale = 1.2;
      else if (zoom === 15) scale = 1.0;
      else if (zoom === 14) scale = 0.6;
      else scale = 0.3;
    } else {
      if (zoom >= 18) scale = 1.0;
      else if (zoom === 17) scale = 0.9;
      else if (zoom === 16) scale = 0.8;
      else if (zoom === 15) scale = 0.5;
      else if (zoom === 14) scale = 0.3;
      else scale = 0.3;
    }
    this.markers.eachLayer(marker => {
      let orderNumber = null;
      if (this.routeSelecting) {
        const idx = this.selectedMarkers.indexOf(marker);
        if (idx !== -1) orderNumber = idx;
      }
      marker.setIcon(this.getCustomIcon(marker.data.type, scale, marker, orderNumber));
      const el = marker.getElement();
      if (el && this.selectedMarkers.includes(marker)) {
        el.classList.add('markerBorder');
      }
    });
    document.getElementById('zoomDisplay').textContent = `Zoom: ${zoom}`;
  }

  showMarkerForm(latlng) {
    const input = prompt('æ–°å¢æ¡é›†é»ï¼ˆåç¨±, æ™‚é–“, é¡è‰²(0-4), å‚™è¨», ç¸½é»æ•¸, åœ°åœ–ç·¨è™Ÿï¼‰', `æ¡é›†é», ç¾åœ¨, ${this.lastMarkerType}, æœªç¢ºèª, 1, 1`);
    if (input) {
      const [name, time, type, remark, totalPoints, mapId] = input.split(',').map(s => s.trim());
      const markerType = Math.min(Math.max(parseInt(type) || 0, 0), 4);
      this.addMarker(latlng, { name, time, type: markerType, remark, lat: latlng.lat, lng: latlng.lng, totalPoints: parseInt(totalPoints, 10) || 1, mapId: parseInt(mapId, 10) || 1 });
      this.lastMarkerType = markerType;
    }
    const infoPanel = document.getElementById('infoPanel');
    if (infoPanel) infoPanel.style.display = '';
    document.getElementById('markerEditModal').style.display = 'none';
  }

  resetAllMarkers() {
    this.markers.eachLayer(m => {
      m.setOpacity(0.6);
      m.setZIndexOffset(0);
    });
  }

  autoAssignTimeForPairedMarker(marker) {
    // Only handle totalPoints = 2
    if (marker.data.totalPoints !== 2) return;

    const selectedTime = marker.data.time;
    const selectedMapId = marker.data.mapId;
    const timeOptions = timeTableByTotalPoints[2];
    const selectedTimeIndex = timeOptions.indexOf(selectedTime);

    // If the selected time is invalid, do nothing
    if (selectedTimeIndex === -1) {
      console.warn('Invalid time selected for marker:', selectedTime);
      return;
    }

    // Find other markers with the same mapId and totalPoints = 2
    let pairedMarkers = [];
    this.markers.eachLayer(m => {
      if (m !== marker && m.data.mapId === selectedMapId && m.data.totalPoints === 2) {
        pairedMarkers.push(m);
      }
    });

    // Warn if multiple paired markers are found
    if (pairedMarkers.length > 1) {
      alert('è­¦å‘Šï¼šæ‰¾åˆ°å¤šå€‹å…·æœ‰ç›¸åŒ mapId å’Œ totalPoints=2 çš„æ¨™è¨˜ï¼Œåªæ›´æ–°ç¬¬ä¸€å€‹ã€‚');
    }

    // Update the first paired marker if found
    if (pairedMarkers.length > 0) {
      const pairedMarker = pairedMarkers[0];
      const alternativeTimeIndex = selectedTimeIndex === 0 ? 1 : 0;
      pairedMarker.data.time = timeOptions[alternativeTimeIndex];
      pairedMarker.setIcon(this.getCustomIcon(pairedMarker.data.type, 1, pairedMarker));
      // Update info panel if the paired marker is selected
      if (this.selectedMarker === pairedMarker) {
        this.updateInfoPanel(pairedMarker.data);
      }
    }
  }

  addMarker(latlng, data) {
    if (!data.totalPoints) data.totalPoints = 1;
    if (!data.mapId) data.mapId = 1;
    const marker = L.marker(latlng, {
      icon: this.getCustomIcon(data.type, 1, { data }),
      draggable: false
    });
    marker.data = data;
    this.resetAllMarkers();
    let tapped = false;
    const handler = (e) => {
      if (tapped) return;
      tapped = true;
      setTimeout(() => tapped = false, 300);
      this.selectedMarker = marker;
      if (this.routeSelecting) {
        const markerElement = marker.getElement();
        if (this.selectedMarkers.includes(marker)) {
          this.selectedMarkers = this.selectedMarkers.filter(m => m !== marker);
          if (markerElement) markerElement.classList.remove('markerBorder');
        } else {
          this.selectedMarkers.push(marker);
          if (markerElement) markerElement.classList.add('markerBorder');
        }
        this.updateMarkerScales();
        return;
      }
      if (this.currentMode === "editMarker") {
        this.resetAllMarkers();
        marker.setOpacity(1.0);
        marker.setZIndexOffset(1000);
        setTimeout(() => {
          const infoPanel = document.getElementById('infoPanel');
          if (infoPanel) infoPanel.style.display = 'none';
          document.getElementById('markerName').value = marker.data.name;
          updateTimeOptionsForEdit(marker.data.totalPoints || 1, marker.data.time);
          document.getElementById('markerType').value = marker.data.type;
          document.getElementById('markerRemark').value = marker.data.remark;
          document.getElementById('markerEditModal').style.display = 'block';
          document.getElementById('saveMarkerBtn').onclick = () => {
            const name = document.getElementById('markerName').value.trim();
            const time = document.getElementById('markerTime').value;
            const type = Math.min(Math.max(parseInt(document.getElementById('markerType').value) || 0, 0), 4);
            const remark = document.getElementById('markerRemark').value.trim();
            marker.data.name = name;
            marker.data.time = time;
            marker.data.type = type;
            marker.data.remark = remark;
            marker.setIcon(this.getCustomIcon(type, 1, marker));

            // Auto-assign time for paired marker if totalPoints = 2
            this.autoAssignTimeForPairedMarker(marker);

            this.updateMarkerScales();
            this.saveMarkers();
            this.updateInfoPanel(marker.data);
            const infoPanel = document.getElementById('infoPanel');
            if (infoPanel) infoPanel.style.display = '';
            document.getElementById('markerEditModal').style.display = 'none';
          };
        }, 0);
      } else {
        this.resetAllMarkers();
        marker.setOpacity(1.0);
        marker.setZIndexOffset(1000);
        this.updateInfoPanel(marker.data);
      }
    };
    marker.on('click', handler);
    marker.on('touchstart', handler);
    this.selectedMarker = marker;
    this.markers.addLayer(marker);
    this.saveMarkers();
    this.filterMarkersByTypes();
    this.updateMarkerScales();
  }

  deleteSelectedMarker() {
    if (!this.selectedMarker) {
      alert('è«‹å…ˆé»é¸ä¸€å€‹æ¨™è¨˜å†åˆªé™¤');
      return;
    }
    if (confirm('ç¢ºå®šè¦åˆªé™¤é€™å€‹æ¨™è¨˜ï¼Ÿ')) {
      this.markers.removeLayer(this.selectedMarker);
      this.saveMarkers();
      this.selectedMarker = null;
      document.getElementById('panelContent').innerText = 'è«‹é»é¸åœ°åœ–ä¸Šçš„æ¨™è¨˜';
    }
  }

  saveMarkers() {
    const saved = [];
    this.markers.eachLayer(marker => saved.push({ ...marker.data, lat: marker.getLatLng().lat, lng: marker.getLatLng().lng }));
    localStorage.setItem('mhnow_markers', JSON.stringify(saved));
  }

  loadSavedMarkers() {
    this.markers.clearLayers();
    const saved = JSON.parse(localStorage.getItem('mhnow_markers') || '[]');
    saved.forEach(data => {
      // å¦‚æœ totalPoints=1ï¼Œå¼·åˆ¶è¨­ç½®æ™‚é–“ç‚ºå”¯ä¸€çš„é¸é …
      if (data.totalPoints === 1) {
        data.time = timeTableByTotalPoints[1][0];
      }
      this.addMarker(L.latLng(data.lat, data.lng), data);
    });
    this.updateMarkerScales();
  }

  filterMarkersByTypes() {
    const selected = Array.from(document.getElementById('filterSelect').selectedOptions)
                         .map(opt => parseInt(opt.value));
    const types = selected.length ? selected : [0, 1, 2, 3, 4];
    this.markers.eachLayer(marker => {
      const icon = marker._icon;
      if (icon) {
        icon.style.visibility = types.includes(marker.data.type) ? 'visible' : 'hidden';
      }
    });
    this.filteredTypes = types;
  }

  confirmImportFromGitHub() {
    if (confirm('ç¢ºå®šå¾ GitHub åŒ¯å…¥æ¨™è¨˜ï¼Ÿé€™å°‡è¦†è“‹ç¾æœ‰æ¨™è¨˜ã€‚')) {
      if (confirm('å†æ¬¡ç¢ºèªï¼šçœŸçš„è¦å¾ GitHub åŒ¯å…¥ä¸¦è¦†è“‹ï¼Ÿ')) {
        this.importFromGitHub();
      }
    }
  }

  importFromGitHub() {
    const url = 'https://raw.githubusercontent.com/kinbak1115/mh-map/main/mhnow_backup_2025-05-12.json';
    fetch(url)
      .then(res => res.json())
      .then(data => {
        if (!Array.isArray(data)) throw new Error();
        localStorage.setItem('mhnow_markers', JSON.stringify(data));
        alert('æˆåŠŸå¾ GitHub åŒ¯å…¥æ¨™è¨˜ï¼Œé‡æ–°è¼‰å…¥åœ°åœ–ã€‚');
        location.reload();
      })
      .catch(() => alert('GitHub åŒ¯å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆé€£çµèˆ‡æ ¼å¼ã€‚'));
  }

  toggleEditMode() {
    if (this.routeSelecting) {
      app.clearAllMarkerBorders();
      this.routeSelecting = false;
      const routeBtn = document.getElementById('routeBtn');
      if (routeBtn) routeBtn.textContent = 'é¸æ“‡è·¯ç·š';
    }
    if (this.currentMode === "done") {
      this.currentMode = "editMarker";
      document.getElementById('editBtn').textContent = "çµæŸç·¨è¼¯";
    } else {
      this.currentMode = "done";
      document.getElementById('editBtn').textContent = "é–‹å§‹ç·¨è¼¯";
      this.saveMarkers();
      document.getElementById('markerEditModal').style.display = 'none';
      const infoPanel = document.getElementById('infoPanel');
      if (infoPanel) infoPanel.style.display = '';
    }
    this.updateMarkerScales();
  }

  toggleSelectingRoute() {
    this.routeSelecting = !this.routeSelecting;
    const button = document.getElementById('routeBtn');
    if (this.routeSelecting) {
      if (this.currentMode !== 'done') {
        this.currentMode = 'done';
        const editBtn = document.getElementById('editBtn');
        if (editBtn) editBtn.textContent = 'é–‹å§‹ç·¨è¼¯';
        document.getElementById('markerEditModal').style.display = 'none';
        const infoPanel = document.getElementById('infoPanel');
        if (infoPanel) infoPanel.style.display = '';
      }
      this.selectedMarkers = [];
      button.textContent = 'å®Œæˆé¸æ“‡';
      this.resetAllMarkers();
    } else {
      app.clearAllMarkerBorders();
      button.textContent = 'é¸æ“‡è·¯ç·š';
    }
    this.updateMarkerScales();
  }

  clearAllMarkerBorders() {
    this.markers.eachLayer(marker => {
      const markerElement = marker.getElement();
      if (markerElement) {
        markerElement.classList.remove('markerBorder');
      }
    });
    this.selectedMarkers = [];
  }

  openGoogleRoute() {
    if (!this.selectedMarkers.length) {
      alert("è«‹å…ˆé¸æ“‡è‡³å°‘ä¸€å€‹æ¨™è¨˜");
      return;
    }
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const current = `${position.coords.latitude},${position.coords.longitude}`;
        const waypoints = this.selectedMarkers.map(m => `${m.getLatLng().lat},${m.getLatLng().lng}`);
        const route = [current, ...waypoints];
        const url = `https://www.google.com/maps/dir/${route.join('/')}`;
        const link = document.createElement('a');
        link.href = url;
        link.target = '_blank';
        link.click();
      },
      () => alert('ç„¡æ³•å–å¾—ä½ çš„ä½ç½®ï¼Œè«‹é–‹å•Ÿå®šä½æ¬Šé™')
    );
  }
}

document.addEventListener('DOMContentLoaded', function() {
  updateTimeOptionsForEdit(1, '');
});

const app = new MapApp();
</script>
</body>
</html>
