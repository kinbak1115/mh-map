<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>MH Now å¤é¾è¨˜éŒ„åœ°åœ–</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css">
  <style>
    body, html { margin: 0; padding: 0; }
    #map { height: 100vh; }
    .leaflet-control-custom {
      background: white;
      padding: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      font-size: 20px;
      width: 300px;
      box-sizing: border-box;
      border-radius: 8px;
    }
    .leaflet-control-custom .btn-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .leaflet-control-custom button {
      flex: 1;
      font-size: 22px;
      padding: 14px;
      min-height: 56px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #f9f9f9;
      cursor: pointer;
      transition: background 0.2s;
    }
    .leaflet-control-custom button:hover {
      background: #e0e0e0;
    }
    select[multiple] {
      width: 100%;
      font-size: 22px;
      padding: 10px;
      margin-bottom: 14px;
      border-radius: 6px;
    }
    @media (max-width: 600px) {
      .leaflet-control-custom {
        width: 100%;
        padding: 18px;
        font-size: 24px;
      }
      .leaflet-control-custom button {
        font-size: 28px;
        padding: 18px;
        min-height: 64px;
      }
      select[multiple], select, input[type="number"] {
        font-size: 28px;
        padding: 12px;
      }
    }
    .marker-wrapper {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .marker-border {
      border-radius: 50%;
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center;
    }
    .markerBorder {
      box-shadow: 0 0 0 6px red;
      border-radius: 50%;
      box-sizing: border-box;
    }
    #version, #zoomDisplay {
      position: absolute;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      font-size: 16px;
      border-radius: 4px;
      z-index: 1000;
    }
    #version { bottom: 10px; }
    #zoomDisplay { bottom: 40px; }
    .info-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 260px;
      background: white;
      padding: 14px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      font-size: 20px;
      z-index: 1000;
    }
    .info-panel h3 {
      margin: 0 0 10px;
      font-size: 22px;
      border-bottom: 1px solid #ccc;
    }
    .info-panel p {
      margin: 10px 0;
    }
    .leaflet-popup-content { display: none; }
    #markerEditModal {
      display: none;
      position: fixed;
      top: 20px;
      left: 20px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 30px 40px;
      z-index: 10000;
      box-shadow: 0 2px 15px rgba(0,0,0,0.4);
      border-radius: 10px;
      width: 260px;
      font-size: 20px;
      line-height: 1.5;
    }
    #markerEditModal h3 {
      margin-top: 0;
      font-size: 26px;
    }
    #markerEditModal select, #markerEditModal input {
      width: 100%;
      font-size: 22px;
      padding: 14px;
      margin-bottom: 14px;
      border-radius: 6px;
    }
    #markerEditModal button {
      font-size: 22px;
      padding: 14px 28px;
      min-height: 56px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #f9f9f9;
      cursor: pointer;
      transition: background 0.2s;
    }
    #markerEditModal button:hover {
      background: #e0e0e0;
    }
    @media (max-width: 600px) {
      #markerEditModal {
        width: 90%;
        padding: 24px;
        font-size: 24px;
      }
      #markerEditModal h3 {
        font-size: 30px;
      }
      #markerEditModal select, #markerEditModal input {
        font-size: 28px;
        padding: 16px;
      }
      #markerEditModal button {
        font-size: 28px;
        padding: 18px 36px;
        min-height: 64px;
      }
    }
  </style>
</head>
<body>

<!-- ğŸŸ¦ Marker ç·¨è¼¯ç”¨ Modalï¼ˆé¡¯ç¤ºåœ¨å·¦ä¸Šè§’ï¼‰ -->
<div id="markerEditModal">
  <h3>æ›´æ”¹æ¨™è¨˜è³‡è¨Š</h3>
  <label for="markerTime">æ™‚é–“ï¼š</label>
  <select id="markerTime">
    <!-- ç”± JS å‹•æ…‹ç”¢ç”Ÿ -->
  </select><br><br>
  <label for="timePeriod">æ™‚é–“æ®µï¼š</label>
  <input type="text" id="timePeriod" readonly><br><br>
  <label for="markerType">é¡è‰²ï¼š</label>
  <select id="markerType">
    <option value="0">âšª åŸå§‹</option>
    <option value="1">ğŸ”´ ç´…</option>
    <option value="2">ğŸ”µ è—</option>
    <option value="3">ğŸŸ¢ ç¶ </option>
    <option value="4">ğŸŸ£ ç´«</option>
  </select><br><br>
  <label for="markerRemark">ç‹€æ…‹ï¼š</label>
  <select id="markerRemark">
    <!-- ç”± JS å‹•æ…‹ç”¢ç”Ÿ -->
  </select><br><br>
  <div style="text-align:right;">
    <button id="saveMarkerBtn">å„²å­˜</button>
    <button onclick="
      document.getElementById('markerEditModal').style.display='none';
      const infoPanel = document.getElementById('infoPanel');
      if (infoPanel) infoPanel.style.display = '';
    ">å–æ¶ˆ</button>
  </div>
</div>

<div id="map"></div>
<div id="infoPanel" class="info-panel">
  <h3>æ¨™è¨˜è³‡è¨Š</h3>
  <div id="panelContent">è«‹é»é¸åœ°åœ–ä¸Šçš„æ¨™è¨˜</div>
</div>
<div id="version">ç‰ˆæœ¬ 4.2.24</div>
<div id="zoomDisplay">Zoom: -</div>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script>
// æ‰€æœ‰æ™‚é–“è¡¨
const timeTableByTotalPoints = {
  1: ["06:15 07:05 07:55 08:45 09:35 10:25 11:15 12:05 12:55 13:45 14:35 15:25 16:15 17:05 17:55 18:45 19:35 20:25 21:15 22:05"],
  2: [
    "06:15 07:55 08:45 09:35 10:25 11:15 12:05 12:55 13:45 14:35 15:25 16:15 17:05 17:55 18:45 19:35 20:25 21:15 22:05 22:55",
    "06:40 08:20 09:10 10:00 10:50 11:40 12:30 13:20 14:10 15:00 15:50 16:40 17:30 18:20 19:10 20:00 20:50 21:40 22:30"
  ],
  3: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:55 10:25 12:55 15:25 17:55 20:25"
  ],
  4: [
    "06:15 07:55 09:35 11:15 12:55 14:35 16:15 17:55 19:35 21:15 22:55",
    "06:40 08:20 10:00 11:40 13:20 15:00 16:40 18:20 20:00 21:40 23:20",
    "07:05 08:45 10:25 12:05 13:45 15:25 17:05 18:45 20:25 22:05",
    "07:30 09:10 10:50 12:30 14:10 15:50 17:30 19:10 20:50 22:30"
  ],
  5: [
    "06:15 08:20 10:25 12:30 14:35 16:40 18:45 20:50 22:55",
    "06:40 08:45 10:50 12:55 15:00 17:05 19:10 21:15 23:20",
    "07:05 09:10 11:15 13:20 15:25 17:30 19:35 21:40",
    "07:30 09:35 11:40 13:45 15:50 17:55 20:00 22:05",
    "07:55 10:00 12:05 14:10 16:15 18:20 20:25 22:30"
  ],
  6: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "06:40 09:10 11:40 14:10 16:40 19:10 21:40",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:30 10:00 12:30 15:00 17:30 20:00 22:30",
    "07:55 10:25 12:55 15:25 17:55 20:25 22:55",
    "08:20 10:50 13:20 15:50 18:20 20:50 23:20"
  ],
  7: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "06:40 09:10 11:40 14:10 16:40 19:10 21:40",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:30 10:00 12:30 15:00 17:30 20:00 22:30",
    "07:55 10:25 12:55 15:25 17:55 20:25 22:55",
    "08:20 10:50 13:20 15:50 18:20 20:50 23:20"
  ],
  8: [
    "06:15 08:45 11:15 13:45 16:15 18:45 21:15",
    "06:40 09:10 11:40 14:10 16:40 19:10 21:40",
    "07:05 09:35 12:05 14:35 17:05 19:35 22:05",
    "07:30 10:00 12:30 15:00 17:30 20:00 22:30",
    "07:55 10:25 12:55 15:25 17:55 20:25 22:55",
    "08:20 10:50 13:20 15:50 18:20 20:50 23:20"
  ]
};

const markerColors = { 0: '', 1: 'red', 2: 'blue', 3: 'green', 4: 'purple' };

// æ‰€æœ‰38ç¨®æ™‚æ®µ
const allTimes = [
  "06:15", "06:40", "07:05", "07:30",
  "07:55", "08:20", "08:45", "09:10",
  "09:35", "10:00", "10:25", "10:50",
  "11:15", "11:40", "12:05", "12:30",
  "12:55", "13:20", "13:45", "14:10",
  "14:35", "15:00", "15:25", "15:50",
  "16:15", "16:40", "17:05", "17:30",
  "17:55", "18:20", "18:45", "19:10",
  "19:35", "20:00", "20:25", "20:50",
  "21:15", "21:40", "22:05", "22:30",
  "22:55", "23:20"
];

// === è¨ˆç®—æ™‚é–“æ®µ ===
function getTimePeriod(totalPoints, timetable, currentTime) {
  const times = timetable.split(/\s+/).filter(Boolean);
  if (!times.length) return "-";

  const now = currentTime || new Date();
  const nowMin = now.getHours() * 60 + now.getMinutes();

  // Define period patterns for each totalPoints
  const periodPatterns = {
    1: Array(20).fill(1), // Single period for all slots
    2: [1, 2], // Alternating 1/2 (confirmed correct)
    3: [1, 2, 3], // Sequential
    4: [1, 2, 1, 2], // Alternating 1/2 to align with ? A ? A
    5: [1, 2, 3, 4, 5], // Sequential
    6: [1, 2, 3, 1, 2, 3], // Repeating 1/2/3
    7: [1, 2, 3, 4, 1, 2, 3], // Repeating 1/2/3/4
    8: [1, 2, 3, 4, 1, 2, 3, 4] // Repeating 1/2/3/4
  };

  let period = "-";
  for (let i = 0; i < times.length; i++) {
    const [h, m] = times[i].split(':').map(Number);
    const timeMin = h * 60 + m;
    const nextTime = times[i + 1] || times[0];
    const [nh, nm] = nextTime.split(':').map(Number);
    let nextTimeMin = nh * 60 + nm;
    if (nextTimeMin < timeMin) nextTimeMin += 24 * 60; // Handle overnight wrap

    if (nowMin >= timeMin && nowMin < nextTimeMin) {
      const pattern = periodPatterns[totalPoints] || Array(times.length).fill(1);
      period = pattern[i % pattern.length].toString();
      break;
    }
  }

  return period;
}

// === æ›´æ–°æ™‚é–“é¸é … ===
function updateTimeOptionsForEdit(totalPoints, selectedTime) {
  const markerTime = document.getElementById('markerTime');
  markerTime.innerHTML = '';
  const arr = timeTableByTotalPoints[totalPoints] || [];
  arr.forEach(timestr => {
    const opt = document.createElement('option');
    opt.value = timestr;
    opt.textContent = timestr;
    markerTime.appendChild(opt);
  });
  if (totalPoints === 1 && arr.length === 1) {
    markerTime.value = arr[0];
  } else if (selectedTime) {
    markerTime.value = selectedTime;
  }

  // æ›´æ–°æ™‚é–“æ®µé¡¯ç¤º
  const timePeriodInput = document.getElementById('timePeriod');
  if (timePeriodInput && arr.length > 0) {
    const timetable = arr[0]; // Use the first timetable for totalPoints
    timePeriodInput.value = getTimePeriod(totalPoints, timetable);
  } else {
    timePeriodInput.value = "-";
  }
}

// === æ›´æ–° remark é¸é … ===
function updateRemarkOptionsForEdit(remark) {
  const markerRemark = document.getElementById('markerRemark');
  const defaultOptions = [
    'A ? A ? ç¢ºèª',
    '? A ? A ç¢ºèª',
    'B ? B ? ç¢ºèª',
    '? B ? B ç¢ºèª',
    'A A A Aç¢ºèª',
    'A B A Bç¢ºèª',
    'B B B Bç¢ºèª',
    'B A B Aç¢ºèª'
  ];
  markerRemark.innerHTML = '';

  defaultOptions.forEach(optValue => {
    const opt = document.createElement('option');
    opt.value = optValue;
    opt.textContent = optValue;
    markerRemark.appendChild(opt);
  });

  if (remark === 'f') {
    const opt = document.createElement('option');
    opt.value = 'f';
    opt.textContent = 'ç„¡æ³•æ¥è§¸/ç„¡æ³•å¤é¾';
    markerRemark.appendChild(opt);
  } else if (remark && !defaultOptions.includes(remark)) {
    const opt = document.createElement('option');
    opt.value = remark;
    opt.textContent = remark;
    markerRemark.appendChild(opt);
  }

  markerRemark.value = remark || '';
}

// === é¸æ“‡æœ€è¿‘çš„å…ˆå‰æ™‚é–“ ===
function getNearestTimeString(marker) {
  let times = (marker.data.time || "").split(/\s+/).filter(Boolean);
  if (!times.length) return "";

  const now = new Date();
  const nowMin = now.getHours() * 60 + now.getMinutes();

  let minDiff = Infinity;
  let bestDisplayTime = "";

  for (const t of times) {
    const m = t.match(/(\d{1,2}):(\d{2})/);
    if (!m) continue;
    const h = parseInt(m[1], 10);
    const mm = parseInt(m[2], 10);
    const total = h * 60 + mm;
    let diff = nowMin - total;
    if (diff < -12 * 60) diff += 24 * 60; // Handle overnight wrap
    if (diff >= 0 && diff < minDiff && diff <= 30) { // Only include times within 30 minutes
      minDiff = diff;
      bestDisplayTime = t;
    }
  }

  return bestDisplayTime;
}

class MapApp {
  constructor() {
    this.map = L.map('map', {
      doubleClickZoom: false
    });
    this.map.locate({ setView: true, maxZoom: 16 });

    this.userMarker = null; // Marker for user's current location
    this.accuracyCircle = null; // Circle for location accuracy
    this.watchId = null; // ID for watchPosition
    this.isTracking = false; // Tracking state

    this.map.on('locationfound', e => this.updateUserLocation(e));
    this.map.on('locationerror', () => {
      alert("ç„¡æ³•å–å¾—ä½ çš„å®šä½ï¼Œä½¿ç”¨é è¨­åœ°é»ã€‚");
      this.map.setView([3.0000, 101.6167], 14);
    });

    this.markers = new L.FeatureGroup();
    this.filteredTypes = [];
    this.lastMarkerType = 0;
    this.routeSelecting = false;
    this.selectedMarkers = [];

    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: 'Â© <a href="https://carto.com/">CARTO</a>'
    }).addTo(this.map);
    this.markers.addTo(this.map);

    this.initControls();
    this.loadSavedMarkers();
    this.initEventListeners();

    this.map.on('zoomend', () => this.updateMarkerScales());
    this.updateMarkerScales();

    setInterval(() => this.updateMarkerScales(), 60 * 1000);
  }

  initControls() {
    const control = L.control({ position: 'topright' });
    control.onAdd = () => {
      const div = L.DomUtil.create('div', 'leaflet-control-custom');
      div.innerHTML = `
        <div class="btn-row">
          <button onclick="app.toggleEditMode()" id="editBtn">é–‹å§‹ç·¨è¼¯</button>
        </div>
        <div class="btn-row">
          <button onclick="app.toggleTracking()" id="trackBtn">é–‹å•Ÿå³æ™‚å®šä½</button>
        </div>
        <label>é¡¯ç¤ºé¡è‰²ï¼š</label>
        <select id="filterSelect" multiple size="5" onchange="app.filterMarkersByTypes()">
          <option value="0">âšª åŸå§‹</option>
          <option value="1">ğŸ”´ ç´…</option>
          <option value="2">ğŸ”µ è—</option>
          <option value="3">ğŸŸ¢ ç¶ </option>
          <option value="4">ğŸŸ£ ç´«</option>
        </select>
        <div class="btn-row">
          <button onclick="app.confirmImportFromGitHub()">ğŸŒ åŒ¯å…¥ GitHub æ¨™è¨˜</button>
        </div>
        <div class="btn-row">
          <button onclick="app.toggleSelectingRoute()" id="routeBtn">é¸æ“‡è·¯ç·š</button>
          <button onclick="app.openGoogleRoute()">ğŸ—ºï¸ Google åœ°åœ–è·¯ç·š</button>
        </div>
      `;
      L.DomEvent.disableClickPropagation(div);
      return div;
    };
    control.addTo(this.map);
    this.currentMode = "done";
  }

  updateUserLocation(e) {
    const latlng = e.latlng;
    const maxRadius = 100;
    const radius = Math.min(e.accuracy / 2, maxRadius);

    // Create or update user marker
    if (!this.userMarker) {
      this.userMarker = L.marker(latlng, {
        icon: L.divIcon({
          className: '',
          html: '<div style="background: blue; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
          iconSize: [12, 12],
          iconAnchor: [6, 6]
        }),
        zIndexOffset: 1000
      }).addTo(this.map);
    } else {
      this.userMarker.setLatLng(latlng);
    }

    // Create or update accuracy circle
    if (!this.accuracyCircle) {
      this.accuracyCircle = L.circle(latlng, {
        radius: radius;
        color: 'blue';
        fillOpacity: 0.2;
        weight: 1
      }).addTo(this.map);
    } else {
      this.accuracyCircle.setLatLng(latlng);
      this.accuracyCircle.setRadius(radius);
    }

    // Center map on first location or if tracking is active
    if (!this.isTracking) {
      this.map.setView(latlng, this.map.getZoom() || 16);
    }
  }

  toggleTracking() {
    this.isTracking = !this.isTracking;
    const trackBtn = document.getElementById('trackBtn');
    if (this.isTracking) {
      trackBtn.textContent = 'é—œé–‰å³æ™‚å®šä½';
      if (navigator.geolocation) {
        this.watchId = navigator.geolocation.watchPosition(
          (position) => {
            const e = {
              latlng: L.latLng(position.coords.latitude, position.coords.longitude),
              accuracy: position.coords.accuracy
            };
            this.updateUserLocation(e);
          },
          () => {
            alert('ç„¡æ³•å–å¾—ä½ çš„ä½ç½®ï¼Œè«‹æª¢æŸ¥å®šä½æ¬Šé™');
            this.stopTracking();
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
          }
        );
      } else {
        alert('ä½ çš„ç€è¦½å™¨ä¸æ”¯æ´åœ°ç†å®šä½');
        this.stopTracking();
      }
    } else {
      this.stopTracking();
    }
  }

  stopTracking() {
    if (this.watchId !== null) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
    }
    this.isTracking = false;
    const trackBtn = document.getElementById('trackBtn');
    if (trackBtn) trackBtn.textContent = 'é–‹å•Ÿå³æ™‚å®šä½';
  }

  updateInfoPanel(data) {
    const displayRemark = data.remark === 'f' ? 'ç„¡æ³•æ¥è§¸/ç„¡æ³•å¤é¾' : (data.remark || '');
    const content = `
      <p>æ™‚é–“ï¼š${data.time}</p>
      <p>é¡å‹ï¼š${markerColors[data.type] || 'åŸå§‹'}</p>
      <p>å‚™è¨»ï¼š${displayRemark}</p>
      <p>åº§æ¨™ï¼š${data.lat ? data.lat.toFixed(6) : ""}, ${data.lng ? data.lng.toFixed(6) : ""}</p>
      <p>åœ°åœ–ç·¨è™Ÿï¼š${data.mapId !== undefined ? data.mapId : ""}</p>
      <p>åœ°å›¾æ€»é‡‡é›†ç‚¹ï¼š${data.totalPoints !== undefined ? data.totalPoints : ""}</p>
    `;
    document.getElementById('panelContent').innerHTML = content;
  }

  initEventListeners() {
    // ç§»é™¤æ‰‹åŠ¨æ·»åŠ æ ‡è®°çš„ç‚¹å‡»/è§¦æ‘¸äº‹ä»¶ç›‘å¬
  }

  getCustomIcon(type = 0, scale = 1, marker = null, orderNumber = null) {
    const iconUrls = {
      0: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/gather.png',
      1: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/redelder.png',
      2: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/blueelder.png',
      3: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/greenelder.png',
      4: 'https://raw.githubusercontent.com/kinbak1115/mh-map/refs/heads/main/elder.png'
    };

    let useIconUrl = iconUrls[type];
    if (marker && marker.data && marker.data.remark && !marker.data.remark.toLowerCase().includes('f')) {
      // Check if the marker is in an ancient dragon state based on remark and time
      const remark = marker.data.remark;
      const times = (marker.data.time || "").split(/\s+/).filter(Boolean);
      if (times.length && remark.includes('ç¢ºèª')) {
        const now = new Date();
        const nowMin = now.getHours() * 60 + now.getMinutes();
        let currentSlot = -1;
        for (let i = 0; i < times.length; i++) {
          const [h, m] = times[i].split(':').map(Number);
          const timeMin = h * 60 + m;
          const nextTime = times[i + 1] || times[0];
          const [nh, nm] = nextTime.split(':').map(Number);
          let nextTimeMin = nh * 60 + nm;
          if (nextTimeMin < timeMin) nextTimeMin += 24 * 60; // Handle overnight wrap
          if (nowMin >= timeMin && nowMin < nextTimeMin) {
            currentSlot = i;
            break;
          }
        }
        if (currentSlot >= 0) {
          // Map remark pattern (e.g., "? A ? A") to the current slot
          const patternMatch = remark.match(/([?AB\s]+)ç¢ºèª/);
          if (patternMatch) {
            const pattern = patternMatch[1].trim().split(/\s+/);
            const patternLength = pattern.length;
            const slotState = pattern[currentSlot % patternLength];
            if (slotState === 'A') {
              useIconUrl = iconUrls[4]; // Use elder.png for ancient dragon state
            }
          }
        }
      }
    }

    let size = 40 * scale;
    let timeStr = getNearestTimeString(marker || { data: {} });

    let timeFontSize = Math.max(10, Math.floor(14 * scale));

    let showRedCross = marker && marker.data && typeof marker.data.remark === 'string' && marker.data.remark.toLowerCase().includes('f');

    const redCrossSVG = `
      <svg width="${size}" height="${size}" style="position:absolute;top:0;left:0;pointer-events:none;z-index:11;" viewBox="0 0 ${size} ${size}">
        <line x1="6" y1="6" x2="${size-6}" y2="${size-6}" stroke="rgba(255,0,0,0.3)" stroke-width="6" stroke-linecap="round"/>
        <line x1="${size-6}" y1="6" x2="6" y2="${size-6}" stroke="rgba(255,0,0,0.3)" stroke-width="6" stroke-linecap="round"/>
      </svg>
    `;

    return L.divIcon({
      className: '',
      html: `
        <div class="marker-wrapper" style="position:relative;">
          <div class="marker-border" style="
            background-image: url('${useIconUrl}');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: ${size}px;
            height: ${size}px;
            position: relative;
          ">
            ${showRedCross ? redCrossSVG : ""}
            ${timeStr ? `<div style="position:absolute;bottom:-18px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.75);color:#fff;font-size:${timeFontSize}px;padding:2px 8px;border-radius:4px;white-space:nowrap;">${timeStr}</div>` : ""}
            ${orderNumber !== null ? `
              <div class="marker-order-badge" style="
                position: absolute;
                top: ${-10 * scale}px;
                left: ${-10 * scale}px;
                width: ${Math.max(20 * scale, 18)}px;
                height: ${Math.max(20 * scale, 18)}px;
                background: #ff6600;
                color: #fff;
                border-radius: 50%;
                font-size: ${Math.max(11 * scale, 12)}px;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                border: ${2 * scale}px solid #fff;
                z-index: 20;
              ">${orderNumber+1}</div>
            ` : ""}
          </div>
        </div>`,
      iconSize: [size, size],
      iconAnchor: [size / 2, size / 2],
      popupAnchor: [0, -size / 2]
    });
  }

  isMobile() {
    return /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
  }

  updateMarkerScales() {
    const zoom = this.map.getZoom();
    const mobile = this.isMobile();
    let scale = 1.0;
    if (mobile) { 
      if (zoom >= 18) scale = 2.0;
      else if (zoom === 17) scale = 1.6;
      else if (zoom === 16) scale = 1.2;
      else if (zoom === 15) scale = 1.0;
      else if (zoom === 14) scale = 0.6;
      else scale = 0.3;
    } else {
      if (zoom >= 18) scale = 1.0;
      else if (zoom === 17) scale = 0.9;
      else if (zoom === 16) scale = 0.8;
      else if (zoom === 15) scale = 0.5;
      else if (zoom === 14) scale = 0.3;
      else scale = 0.3;
    }
    this.markers.eachLayer(marker => {
      let orderNumber = null;
      if (this.routeSelecting) {
        const idx = this.selectedMarkers.indexOf(marker);
        if (idx !== -1) orderNumber = idx;
      }
      marker.setIcon(this.getCustomIcon(marker.data.type, scale, marker, orderNumber));
      const el = marker.getElement();
      if (el && this.selectedMarkers.includes(marker)) {
        el.classList.add('markerBorder');
      }
    });
    document.getElementById('zoomDisplay').textContent = `Zoom: ${zoom}`;
  }

  addMarker(latlng, data) {
    if (!data.totalPoints) data.totalPoints = 1;
    if (!data.mapId) data.mapId = 1;
    if (!data.remark) data.remark = '';
    const marker = L.marker(latlng, {
      icon: this.getCustomIcon(data.type, 1, { data }),
      draggable: false
    });
    marker.data = data;
    this.resetAllMarkers();
    let tapped = false;
    const handler = (e) => {
      if (tapped) return;
      tapped = true;
      setTimeout(() => tapped = false, 300);
      this.selectedMarker = marker;
      if (this.routeSelecting) {
        const markerElement = marker.getElement();
        if (this.selectedMarkers.includes(marker)) {
          this.selectedMarkers = this.selectedMarkers.filter(m => m !== marker);
          if (markerElement) markerElement.classList.remove('markerBorder');
        } else {
          this.selectedMarkers.push(marker);
          if (markerElement) markerElement.classList.add('markerBorder');
        }
        this.updateMarkerScales();
        return;
      }
      if (this.currentMode === "editMarker") {
        this.resetAllMarkers();
        marker.setOpacity(1.0);
        marker.setZIndexOffset(1000);
        setTimeout(() => {
          const infoPanel = document.getElementById('infoPanel');
          if (infoPanel) infoPanel.style.display = 'none';
          updateTimeOptionsForEdit(marker.data.totalPoints || 1, marker.data.time);
          document.getElementById('markerType').value = marker.data.type;
          updateRemarkOptionsForEdit(marker.data.remark);
          document.getElementById('markerEditModal').style.display = 'block';
          document.getElementById('saveMarkerBtn').onclick = () => {
            const time = document.getElementById('markerTime').value;
            const type = Math.min(Math.max(parseInt(document.getElementById('markerType').value) || 0, 0), 4);
            const remark = document.getElementById('markerRemark').value.trim();
            marker.data.time = time;
            marker.data.type = type;
            marker.data.remark = remark;
            marker.setIcon(this.getCustomIcon(type, 1, marker));

            this.autoAssignTimeForRelatedMarkers(marker);

            this.updateMarkerScales();
            this.saveMarkers();
            this.updateInfoPanel(marker.data);
            const infoPanel = document.getElementById('infoPanel');
            if (infoPanel) infoPanel.style.display = '';
            document.getElementById('markerEditModal').style.display = 'none';
          };
        }, 0);
      } else {
        this.resetAllMarkers();
        marker.setOpacity(1.0);
        marker.setZIndexOffset(1000);
        this.updateInfoPanel(marker.data);
      }
    };
    marker.on('click', handler);
    marker.on('touchstart', handler);
    this.selectedMarker = marker;
    this.markers.addLayer(marker);
    this.saveMarkers();
    this.filterMarkersByTypes();
    this.updateMarkerScales();
  }

  resetAllMarkers() {
    this.markers.eachLayer(m => {
      m.setOpacity(0.6);
      m.setZIndexOffset(0);
    });
  }

  autoAssignTimeForRelatedMarkers(marker) {
    const totalPoints = marker.data.totalPoints;
    if (![2, 3, 4, 5, 6].includes(totalPoints)) return;

    const selectedTime = marker.data.time;
    const selectedMapId = marker.data.mapId;
    const timeOptions = timeTableByTotalPoints[totalPoints];
    const selectedTimeIndex = timeOptions.indexOf(selectedTime);

    if (selectedTimeIndex === -1) {
      console.warn('Invalid time selected for marker:', selectedTime);
      return;
    }

    let relatedMarkers = [];
    this.markers.eachLayer(m => {
      if (m !== marker && m.data.mapId === selectedMapId && m.data.totalPoints === totalPoints) {
        relatedMarkers.push(m);
      }
    });

    const maxRelated = totalPoints - 1;
    if (relatedMarkers.length > maxRelated) {
      alert(`è­¦å‘Šï¼šæ‰¾åˆ°å¤šå€‹å…·æœ‰ç›¸åŒ mapId å’Œ totalPoints=${totalPoints} çš„æ¨™è¨˜ï¼Œåªæ›´æ–°å‰ ${maxRelated} å€‹ã€‚`);
      relatedMarkers = relatedMarkers.slice(0, maxRelated);
    }

    const usedIndices = [selectedTimeIndex];
    relatedMarkers.forEach(m => {
      const idx = timeOptions.indexOf(m.data.time);
      if (idx !== -1) usedIndices.push(idx);
    });

    if (usedIndices.length >= maxRelated && relatedMarkers.length >= maxRelated) {
      const availableIndices = Array.from({ length: timeOptions.length }, (_, i) => i).filter(i => !usedIndices.includes(i));
      if (availableIndices.length > 0) {
        const nthMarker = relatedMarkers.find(m => !usedIndices.includes(timeOptions.indexOf(m.data.time)) || timeOptions.indexOf(m.data.time) === -1) || 
                         relatedMarkers[relatedMarkers.length - 1];
        if (nthMarker) {
          nthMarker.data.time = timeOptions[availableIndices[0]];
          nthMarker.setIcon(this.getCustomIcon(nthMarker.data.type, 1, nthMarker));
          if (this.selectedMarker === nthMarker) {
            this.updateInfoPanel(nthMarker.data);
          }
        }
      }
    }
  }

  saveMarkers() {
    const saved = [];
    this.markers.eachLayer(marker => saved.push({ ...marker.data, lat: marker.getLatLng().lat, lng: marker.getLatLng().lng }));
    localStorage.setItem('mhnow_markers', JSON.stringify(saved));
  }

  loadSavedMarkers() {
    this.markers.clearLayers();
    const saved = JSON.parse(localStorage.getItem('mhnow_markers') || '[]');
    saved.forEach(data => {
      if (data.totalPoints === 1) {
        data.time = timeTableByTotalPoints[1][0];
      }
      delete data.name;
      this.addMarker(L.latLng(data.lat, data.lng), data);
    });
    this.updateMarkerScales();
  }

  filterMarkersByTypes() {
    const selected = Array.from(document.getElementById('filterSelect').selectedOptions)
                         .map(opt => parseInt(opt.value));
    const types = selected.length ? selected : [0, 1, 2, 3, 4];
    this.markers.eachLayer(marker => {
      const icon = marker._icon;
      if (icon) {
        icon.style.visibility = types.includes(marker.data.type) ? 'visible' : 'hidden';
      }
    });
    this.filteredTypes = types;
  }

  confirmImportFromGitHub() {
    if (confirm('ç¢ºå®šå¾ GitHub åŒ¯å…¥æ¨™è¨˜ï¼Ÿé€™å°‡è¦†è“‹ç¾æœ‰æ¨™è¨˜ã€‚')) {
      if (confirm('å†æ¬¡ç¢ºèªï¼šçœŸçš„è¦å¾ GitHub åŒ¯å…¥ä¸¦è¦†è“‹ï¼Ÿ')) {
        this.importFromGitHub();
      }
    }
  }

  importFromGitHub() {
    const url = 'https://raw.githubusercontent.com/kinbak1115/mh-map/main/mhnow_backup_2025-05-12.json';
    fetch(url)
      .then(res => res.json())
      .then(data => {
        if (!Array.isArray(data)) throw new Error();
        data.forEach(item => delete item.name);
        localStorage.setItem('mhnow_markers', JSON.stringify(data));
        alert('æˆåŠŸå¾ GitHub åŒ¯å…¥æ¨™è¨˜ï¼Œé‡æ–°è¼‰å…¥åœ°åœ–ã€‚');
        location.reload();
      })
      .catch(() => alert('GitHub åŒ¯å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆé€£çµèˆ‡æ ¼å¼ã€‚'));
  }

  toggleEditMode() {
    if (this.routeSelecting) {
      this.clearAllMarkerBorders();
      this.routeSelecting = false;
      const routeBtn = document.getElementById('routeBtn');
      if (routeBtn) routeBtn.textContent = 'é¸æ“‡è·¯ç·š';
    }
    if (this.currentMode === "done") {
      this.currentMode = "editMarker";
      document.getElementById('editBtn').textContent = "çµæŸç·¨è¼¯";
    } else {
      this.currentMode = "done";
      document.getElementById('editBtn').textContent = "é–‹å§‹ç·¨è¼¯";
      this.saveMarkers();
      document.getElementById('markerEditModal').style.display = 'none';
      const infoPanel = document.getElementById('infoPanel');
      if (infoPanel) infoPanel.style.display = '';
    }
    this.updateMarkerScales();
  }

  toggleSelectingRoute() {
    this.routeSelecting = !this.routeSelecting;
    const button = document.getElementById('routeBtn');
    if (this.routeSelecting) {
      if (this.currentMode !== 'done') {
        this.currentMode = 'done';
        const editBtn = document.getElementById('editBtn');
        if (editBtn) editBtn.textContent = 'é–‹å§‹ç·¨è¼¯';
        document.getElementById('markerEditModal').style.display = 'none';
        const infoPanel = document.getElementById('infoPanel');
        if (infoPanel) infoPanel.style.display = '';
      }
      this.selectedMarkers = [];
      button.textContent = 'å®Œæˆé¸æ“‡';
      this.resetAllMarkers();
    } else {
      this.clearAllMarkerBorders();
      button.textContent = 'é¸æ“‡è·¯ç·š';
    }
    this.updateMarkerScales();
  }

  clearAllMarkerBorders() {
    this.markers.eachLayer(marker => {
      const markerElement = marker.getElement();
      if (markerElement) {
        markerElement.classList.remove('markerBorder');
      }
    });
    this.selectedMarkers = [];
  }

  openGoogleRoute() {
    if (!this.selectedMarkers.length) {
      alert("è«‹é»é¸è‡³å°‘ä¸€å€‹æ¨™è¨˜");
      return;
    }
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const current = `${position.coords.latitude},${position.coords.longitude}`;
        const waypoints = this.selectedMarkers.map(m => `${m.getLatLng().lat},${m.getLatLng().lng}`);
        const route = [current, ...waypoints];
        const url = `https://www.google.com/maps/dir/${route.join(',')}`;
        const link = document.createElement('a');
        link.href = url;
        link.target = '_blank';
        link.click();
      },
      () => alert('ç„¡æ³•å–å¾—ä½ çš„ä½ç½®ï¼Œè«‹é–‹å•Ÿå®šä½æ¬Šé™')
    );
  }
}

document.addEventListener('DOMContentLoaded', function() {
  updateTimeOptionsForEdit(1, '');
});

const app = new MapApp();
</script>
</body>
</html>
